<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Arageli: gcd.hpp File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>gcd.hpp File Reference</h1><code>#include &quot;<a class="el" href="config_8hpp-source.html">config.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="type__traits_8hpp-source.html">type_traits.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="factory_8hpp-source.html">factory.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="cmp_8hpp-source.html">cmp.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="vector_8hpp-source.html">vector.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="std__import_8hpp-source.html">std_import.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="gcd_8cpp-source.html">gcd.cpp</a>&quot;</code><br>

<p>
<a href="gcd_8hpp-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html">Arageli</a></td></tr>

<tr><td colspan="2"><br><h2>The Euclidean algorithm.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#8712c4feea3750327e3f589d6cff14bb">Arageli::euclid</a> (T a, T b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes the Euclidean algorithm on a and b.  <a href="#8712c4feea3750327e3f589d6cff14bb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#3d631ea168eca9409ecb2f2b2ef1efab">Arageli::euclid</a> (const T &amp;a, const T &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes the Euclidean algorithm on a and b.  <a href="#3d631ea168eca9409ecb2f2b2ef1efab"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#a6bd991efc000e574354a6b73c70f303">Arageli::euclid_binary</a> (T a, T b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes the Euclidean algorithm on a and b.  <a href="#a6bd991efc000e574354a6b73c70f303"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#8c6fa8287458f12de66db9248621c534">Arageli::euclid_binary</a> (const T &amp;a, const T &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes the Euclidean algorithm on a and b.  <a href="#8c6fa8287458f12de66db9248621c534"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T_factory, typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#736c95de427342fc2a483eadffc459d6">Arageli::euclid</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T1, REFCNT1 &gt; &amp;b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes Euclidean algorithm for each corresponding pair of a and b.  <a href="#736c95de427342fc2a483eadffc459d6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#51f0493b58d406603807370cfbc2d7af">Arageli::euclid</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T1, REFCNT1 &gt; &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes Euclidean algorithm for each corresponding pair of a and b.  <a href="#51f0493b58d406603807370cfbc2d7af"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#8bfd65f8e4fc2ef12cdf85d3150cb9ba">Arageli::euclid_bezout</a> (const T &amp;a, const T &amp;b, T &amp;u, T &amp;v, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The greatest common divisor and Bezout's coefficients.  <a href="#8bfd65f8e4fc2ef12cdf85d3150cb9ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#75c9d99cf7735c5cc9ad03b2cfe9e2aa">Arageli::euclid_bezout</a> (const T &amp;a, const T &amp;b, T &amp;u, T &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The greatest common divisor and Bezout's coefficients.  <a href="#75c9d99cf7735c5cc9ad03b2cfe9e2aa"></a><br></td></tr>
<tr><td colspan="2"><br><h2>The GCD and LCM algorithms.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#f89fa95bfc73bf5490b6c4a0cb35ffd1">Arageli::gcd</a> (const T &amp;a, const T &amp;b, const T_factory &amp;tfctr, const type_category::type &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#4013850934645e0413d20c5fc16aca34">Arageli::gcd</a> (const T &amp;a, const T &amp;b, const T_factory &amp;tfctr, const type_category::integer &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#25c165cb15d17b3bc23340b082f2556a">Arageli::gcd</a> (const T &amp;a, const T &amp;b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes GCD for a and b.  <a href="#25c165cb15d17b3bc23340b082f2556a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#13ffb4a6c05581e21de634d2303b0780">Arageli::gcd</a> (const T &amp;a, const T &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes GCD for a and b.  <a href="#13ffb4a6c05581e21de634d2303b0780"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T1&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#1a72170b93139a356dfeb02510d0321b">Arageli::gcd</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes GCD for a and b.  <a href="#1a72170b93139a356dfeb02510d0321b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#22a59ba83fa471e7bd8bd04eecd60761">Arageli::gcd</a> (const vector&lt; T, REFCNT &gt; &amp;x, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes GCD for all items of vector 'x'.  <a href="#22a59ba83fa471e7bd8bd04eecd60761"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#63cddd6324f395cee10757610b5fc1d5">Arageli::gcd</a> (const vector&lt; T, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes GCD for all items of vector 'x'.  <a href="#63cddd6324f395cee10757610b5fc1d5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#b29a7062e998f938e38172a3b77bf77b">Arageli::gcd3</a> (const T &amp;a, const T &amp;b, const T &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute GCD(a, b, c).  <a href="#b29a7062e998f938e38172a3b77bf77b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#bdb080b784642a20ab195665c3e5c5ed">Arageli::gcdex</a> (const T &amp;a, const T &amp;b, T &amp;u, T &amp;v, T &amp;w, T &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended GCD; abs(u*z - w*v) == 1; a*w + b*z == 0.  <a href="#bdb080b784642a20ab195665c3e5c5ed"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#8cc31a422706d6118b71c7c1ad881190">Arageli::gcdex</a> (const T &amp;a, const T &amp;b, const T &amp;N, T &amp;u, T &amp;v, T &amp;w, T &amp;z)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T_factory, typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#1f250f41e6545e92e710c74fc41cd2c4">Arageli::gcd_vec</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T1, REFCNT1 &gt; &amp;b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes GCD for each corresponding pair of a and b.  <a href="#1f250f41e6545e92e710c74fc41cd2c4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T_factory, typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#27b567bcbf47a75ce4162a943150dd4b">Arageli::gcd</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T1, REFCNT1 &gt; &amp;b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes GCD for each corresponding pair of a and b.  <a href="#27b567bcbf47a75ce4162a943150dd4b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#5b0cc18287b09064e92540aa81f303d3">Arageli::gcd</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T, REFCNT &gt; &amp;b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes GCD for each corresponding pair of a and b.  <a href="#5b0cc18287b09064e92540aa81f303d3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#fc7838e192f6ce1a9423dc7b52ac4d7c">Arageli::gcd</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T1, REFCNT1 &gt; &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes GCD for each corresponding pair of a and b.  <a href="#fc7838e192f6ce1a9423dc7b52ac4d7c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#65e7a83e0f684873f8397a9f1c896328">Arageli::gcd</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T, REFCNT &gt; &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes GCD for each corresponding pair of a and b.  <a href="#65e7a83e0f684873f8397a9f1c896328"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#a7a1acb7f432854648daf66dad31b255">Arageli::lcm</a> (const T &amp;a, const T &amp;b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes LCM for a and b.  <a href="#a7a1acb7f432854648daf66dad31b255"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#d5f53e6f8cf4f90fde3b53c5cefaf346">Arageli::lcm</a> (const T &amp;a, const T &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes LCM for a and b.  <a href="#d5f53e6f8cf4f90fde3b53c5cefaf346"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#9f8529ae9823cb5776f34d44ea491846">Arageli::lcm</a> (const vector&lt; T, REFCNT &gt; &amp;x, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes LCM for all items of vector 'x'.  <a href="#9f8529ae9823cb5776f34d44ea491846"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#25fe8ff050a5705788acfd70dba205cf">Arageli::lcm</a> (const vector&lt; T, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes LCM for all items of vector 'x'.  <a href="#25fe8ff050a5705788acfd70dba205cf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T_factory, typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#5d20fef03901dec13bfc038c35ab85a7">Arageli::lcm_vec</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T1, REFCNT1 &gt; &amp;b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes LCM for each corresponding pair of a and b.  <a href="#5d20fef03901dec13bfc038c35ab85a7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T_factory, typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#30863890bcfc5d32f6230a9ef10415e1">Arageli::lcm</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T1, REFCNT1 &gt; &amp;b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes LCM for each corresponding pair of a and b.  <a href="#30863890bcfc5d32f6230a9ef10415e1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#8f0baff76822735073cbb6cadcfe4a53">Arageli::lcm</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T, REFCNT &gt; &amp;b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes LCM for each corresponding pair of a and b.  <a href="#8f0baff76822735073cbb6cadcfe4a53"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e8a60cd98bc9c0f6b62d4f0ba3710251">Arageli::lcm</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T1, REFCNT1 &gt; &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes LCM for each corresponding pair of a and b.  <a href="#e8a60cd98bc9c0f6b62d4f0ba3710251"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">vector&lt; T, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e8143cc55dd66a5a1019b7607ccd4f41">Arageli::lcm</a> (const vector&lt; T, REFCNT &gt; &amp;a, const vector&lt; T, REFCNT &gt; &amp;b)</td></tr>

<tr><td colspan="2"><br><h2>A test for relative primality.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#3e39bb9e7ec1df3845845f12515b5a89">Arageli::is_coprime</a> (const T &amp;a, const T &amp;b, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if two objects are coprime.  <a href="#3e39bb9e7ec1df3845845f12515b5a89"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7a9b2a29927fe80b2d436bfe17ba5ca8">Arageli::is_coprime</a> (const T &amp;a, const T &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if two objects are coprime.  <a href="#7a9b2a29927fe80b2d436bfe17ba5ca8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename T_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#c93833c15ca994673dadf1fcc89b965c">Arageli::is_coprime</a> (const vector&lt; T, REFCNT &gt; &amp;x, const T_factory &amp;tfctr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if all objects in the vector are coprime.  <a href="#c93833c15ca994673dadf1fcc89b965c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#973a989c7ad8a5a82321259ec7d53d16">Arageli::is_coprime</a> (const vector&lt; T, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if all objects in the vector are coprime.  <a href="#973a989c7ad8a5a82321259ec7d53d16"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gcd_8hpp.html#496a5d5cbf59c6fc145eaa7333d25aca">ARAGELI_INCLUDE_CPP_WITH_EXPORT_TEMPLATE_GCD</a></td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="496a5d5cbf59c6fc145eaa7333d25aca"></a><!-- doxytag: member="gcd.hpp::ARAGELI_INCLUDE_CPP_WITH_EXPORT_TEMPLATE_GCD" ref="496a5d5cbf59c6fc145eaa7333d25aca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARAGELI_INCLUDE_CPP_WITH_EXPORT_TEMPLATE_GCD          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="gcd_8hpp-source.html#l00333">333</a> of file <a class="el" href="gcd_8hpp-source.html">gcd.hpp</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Aug 31 17:38:17 2006 for Arageli by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
