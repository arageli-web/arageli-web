<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Arageli: simplex_method.hpp File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>simplex_method.hpp File Reference</h1><code>#include &quot;<a class="el" href="config_8hpp-source.html">config.hpp</a>&quot;</code><br>
<code>#include &lt;cstddef&gt;</code><br>
<code>#include &lt;iostream&gt;</code><br>
<code>#include &lt;iomanip&gt;</code><br>
<code>#include &lt;algorithm&gt;</code><br>
<code>#include &quot;<a class="el" href="factory_8hpp-source.html">factory.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="exception_8hpp-source.html">exception.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="cmp_8hpp-source.html">cmp.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="vector_8hpp-source.html">vector.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="matrix_8hpp-source.html">matrix.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="gauss_8hpp-source.html">gauss.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="std__import_8hpp-source.html">std_import.hpp</a>&quot;</code><br>

<p>
<a href="simplex__method_8hpp-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html">Arageli</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html">Arageli::simplex_method</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1ctrl.html">Arageli::ctrl</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1ctrl_1_1simplex__method.html">Arageli::ctrl::simplex_method</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1rule__s__primal__first.html">Arageli::simplex_method::rule_s_primal_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule to choice the first appropriate column as pivot in the primal simplex method.  <a href="struct_arageli_1_1simplex__method_1_1rule__s__primal__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1rule__r__primal__first.html">Arageli::simplex_method::rule_r_primal_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule to choice the first appropriate row as pivot in the primal simplex method.  <a href="struct_arageli_1_1simplex__method_1_1rule__r__primal__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1rule__r__primal__lex.html">Arageli::simplex_method::rule_r_primal_lex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule to choice the lexmin appropriate row as pivot in the primal simplex method.  <a href="struct_arageli_1_1simplex__method_1_1rule__r__primal__lex.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1rule__r__dual__first.html">Arageli::simplex_method::rule_r_dual_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule to choice the first appropriate row as pivot in the dual simplex method.  <a href="struct_arageli_1_1simplex__method_1_1rule__r__dual__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1rule__s__dual__first.html">Arageli::simplex_method::rule_s_dual_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule to choice the first appropriate column as pivot in the dual simplex method.  <a href="struct_arageli_1_1simplex__method_1_1rule__s__dual__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1primal__row__iters__idler.html">Arageli::ctrl::simplex_method::primal_row_iters_idler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default controller for the primal_row_iters function. It's doing nothing.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1primal__row__iters__idler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1ctrl_1_1simplex__method_1_1primal__row__iters__idler_1_1abort.html">Arageli::ctrl::simplex_method::primal_row_iters_idler::abort</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1primal__col__iter__idler.html">Arageli::ctrl::simplex_method::primal_col_iter_idler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default controller for the primal_col_iter function. It's doing nothing.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1primal__col__iter__idler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1primal__col__iter__slog.html">Arageli::ctrl::simplex_method::primal_col_iter_slog&lt; Stream &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple controller for the primal_col_iter function. It outputs into a stream.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1primal__col__iter__slog.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1primal__col__iters__idler.html">Arageli::ctrl::simplex_method::primal_col_iters_idler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default controller for the primal_col_iters function. It's doing nothing.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1primal__col__iters__idler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1dual__col__iter__idler.html">Arageli::ctrl::simplex_method::dual_col_iter_idler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default controller for the dual_col_iter function. It's doing nothing.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1dual__col__iter__idler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1dual__col__iter__slog.html">Arageli::ctrl::simplex_method::dual_col_iter_slog&lt; Stream &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple controller for the primal_col_iter function. It outputs into a stream.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1dual__col__iter__slog.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1dual__col__iters__idler.html">Arageli::ctrl::simplex_method::dual_col_iters_idler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default controller for the dual_col_iters function. It's doing nothing.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1dual__col__iters__idler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1basis__create__by__artificial__idler.html">Arageli::ctrl::simplex_method::basis_create_by_artificial_idler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default controller for the basis_create_by_artificial function. It's doing nothing.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1basis__create__by__artificial__idler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1ctrl_1_1simplex__method_1_1basis__create__by__artificial__idler_1_1abort.html">Arageli::ctrl::simplex_method::basis_create_by_artificial_idler::abort</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1basis__artificial__idler.html">Arageli::ctrl::simplex_method::basis_artificial_idler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default controller for the primal_row_iters function. It's doing nothing.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1basis__artificial__idler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1ctrl_1_1simplex__method_1_1basis__artificial__idler_1_1abort.html">Arageli::ctrl::simplex_method::basis_artificial_idler::abort</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1primal__row__with__artificial__basis__idler.html">Arageli::ctrl::simplex_method::primal_row_with_artificial_basis_idler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default controller for the primal_row_with_artificial_basis function. It's doing nothing.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1primal__row__with__artificial__basis__idler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1gomory1__iter__idler.html">Arageli::ctrl::simplex_method::gomory1_iter_idler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default controller for the primal_row_iters function. It's doing nothing.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1gomory1__iter__idler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1ctrl_1_1simplex__method_1_1gomory1__iter__idler_1_1abort.html">Arageli::ctrl::simplex_method::gomory1_iter_idler::abort</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1ctrl_1_1simplex__method_1_1gomory1__iters__idler.html">Arageli::ctrl::simplex_method::gomory1_iters_idler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default controller for the primal_row_iters function. It's doing nothing.  <a href="struct_arageli_1_1ctrl_1_1simplex__method_1_1gomory1__iters__idler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1ctrl_1_1simplex__method_1_1gomory1__iters__idler_1_1abort.html">Arageli::ctrl::simplex_method::gomory1_iters_idler::abort</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1linear__prog__task__base.html">Arageli::simplex_method::linear_prog_task_base</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1simplex__method_1_1linear__prog__task.html">Arageli::simplex_method::linear_prog_task&lt; T, REFCNT &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Model of the linear programming task with partial integer constraints.  <a href="class_arageli_1_1simplex__method_1_1linear__prog__task.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Looking for parts of a simplex table that is not satisfied certain criterion.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">matrix&lt; T1, REFCNT1 &gt;::size_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#1d6423aa66e8dfe9f76bb554bfdc3eb0">Arageli::simplex_method::find_row_notallow</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the first not allowable basis column in a row simplex table.  <a href="#1d6423aa66e8dfe9f76bb554bfdc3eb0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">matrix&lt; T1, REFCNT1 &gt;::size_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#3a286fcd732b0d800db2da67d3f7270a">Arageli::simplex_method::find_col_notallow</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the first not allowable basis row in a column simplex table.  <a href="#3a286fcd732b0d800db2da67d3f7270a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">matrix&lt; T1, REFCNT1 &gt;::size_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#c1551b14bd931a3136a656a79f72f7c5">Arageli::simplex_method::find_primal_notallow</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the first not allowable row in a primal simplex table.  <a href="#c1551b14bd931a3136a656a79f72f7c5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">matrix&lt; T1, REFCNT1 &gt;::size_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#e0d5494eb3d0172b82e5eb39dfc94d9e">Arageli::simplex_method::find_dual_notallow</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the first not allowable column in a dual simplex table.  <a href="#e0d5494eb3d0172b82e5eb39dfc94d9e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Determination type of a simplex table.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#ae299d52b5754eef4b7cb931dbc70bb9">Arageli::simplex_method::is_row_allow</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if simplex table 'a' with basis 'basis' is row simplex table.  <a href="#ae299d52b5754eef4b7cb931dbc70bb9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#f90e3389612f89a617f71e017e8612ef">Arageli::simplex_method::is_col_allow</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if simplex table 'a' with nonbasis 'nonbasis' is column simplex table.  <a href="#f90e3389612f89a617f71e017e8612ef"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#a9091e85b62b293d6ac96de8bd17e36a">Arageli::simplex_method::is_primal_allow</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if simplex table 'a' is primal allowable.  <a href="#a9091e85b62b293d6ac96de8bd17e36a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#ec8036ab5d63334ccf70c908dd62df35">Arageli::simplex_method::is_dual_allow</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if simplex table 'a' is dual allowable.  <a href="#ec8036ab5d63334ccf70c908dd62df35"></a><br></td></tr>
<tr><td colspan="2"><br><h2>The primal row iterations on a row simplex table.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename T_pivot, typename Rule_s, typename Rule_r&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#8448987e8a257d10932c95347913b9fd">Arageli::simplex_method::primal_row_iter</a> (matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, T_pivot &amp;prow, T_pivot &amp;pcol, Rule_s rule_s, Rule_r rule_r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one primal row iteration on a row simplex table.  <a href="#8448987e8a257d10932c95347913b9fd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#1a9f948924281eb8c87ef4c7c330ebfc">Arageli::simplex_method::primal_row_iter</a> (matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one primal row iteration on a row simplex table.  <a href="#1a9f948924281eb8c87ef4c7c330ebfc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename Rule_s, typename Rule_r&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#ebee38df4371fceb43d2308137045e6a">Arageli::simplex_method::primal_row_iter</a> (matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, Rule_s rule_s, Rule_r rule_r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one primal row iteration on a row simplex table.  <a href="#ebee38df4371fceb43d2308137045e6a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename T_pivot&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#7c0c98b6f0efd108aa2208e8163b5bb7">Arageli::simplex_method::primal_row_iter_pivotout</a> (matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, T_pivot &amp;prow, T_pivot &amp;pcol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one primal row iteration on a row simplex table.  <a href="#7c0c98b6f0efd108aa2208e8163b5bb7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Artificial basis method.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#9df1c452c2514f5b0830426a27851d9c">Arageli::simplex_method::artificial_basis_create</a> (matrix&lt; T1, REFCNT1 &gt; &amp;a, vector&lt; T2, REFCNT2 &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates artificial task to find valid basis by the artifical basis method.  <a href="#9df1c452c2514f5b0830426a27851d9c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>The Gomory's algorithms.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename Prow&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#f482dc27ab9497074b083db85ba0b964">Arageli::simplex_method::gomory1_clip</a> (matrix&lt; T, REFCNT &gt; &amp;t, Prow &amp;prow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates Gomory's clip on optimal column simplex table.  <a href="#f482dc27ab9497074b083db85ba0b964"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#7e3086eb267e4646b6af8b3002c55d60">Arageli::simplex_method::gomory1_clip</a> (matrix&lt; T, REFCNT &gt; &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates Gomory's clip on optimal column simplex table.  <a href="#7e3086eb267e4646b6af8b3002c55d60"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="simplex__method_8hpp.html#0e8d3805eef1a357fe480e5f0e373a2d">ARAGELI_INCLUDE_CPP_WITH_EXPORT_TEMPLATE_SIMPLEX_METHOD</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">Arageli::simplex_method::result_kind</a> { <a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb82b7efdb2b1c7d7e713dc2994e28c05d1">Arageli::simplex_method::rk_found</a>, 
<a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb818093ce7fda36b00c981f3b7fd8b82ac">Arageli::simplex_method::rk_empty</a>, 
<a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8fa34f440778e0b21ed8f0ecf6beb9e94">Arageli::simplex_method::rk_infinite</a>, 
<a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb82df658024b6527375fbc6c3e5e64e968">Arageli::simplex_method::rk_nonoptimal</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">General kind of result of one or more iterations of the simplex method.  <a href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#7a4a7a2724a001ade6147f0e522a128b">Arageli::simplex_method::primal_row_iters</a> (matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous primal row iterations on a row simplex table.  <a href="#7a4a7a2724a001ade6147f0e522a128b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#701d27f8228e91c6b4b7786c25eb06e5">Arageli::simplex_method::primal_row_iters</a> (matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous primal row iterations on a row simplex table.  <a href="#701d27f8228e91c6b4b7786c25eb06e5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#ddaf738e002dcac01bb29ba4872bb4dd">Arageli::simplex_method::primal_row_iters</a> (matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous primal row iterations on a row simplex table.  <a href="#ddaf738e002dcac01bb29ba4872bb4dd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#cfb91f2ca05aea0249391bc2027dba9b">Arageli::simplex_method::primal_col_iters</a> (matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous primal colunt iterations on a column simplex table.  <a href="#cfb91f2ca05aea0249391bc2027dba9b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#12b7affc53c0c508e4f06bad8a38812a">Arageli::simplex_method::primal_col_iters</a> (matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous primal column iterations on a column simplex table.  <a href="#12b7affc53c0c508e4f06bad8a38812a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#0a4d6ef23a0fdef4b5f398cca7025218">Arageli::simplex_method::dual_col_iter</a> (matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one dual column iteration on a column simplex table.  <a href="#0a4d6ef23a0fdef4b5f398cca7025218"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#de8558c4783f9faf991b8b35902e379c">Arageli::simplex_method::dual_col_iter</a> (matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one dual column iteration on a column simplex table.  <a href="#de8558c4783f9faf991b8b35902e379c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#b23a59a732c583d329d98b0b2f697e04">Arageli::simplex_method::dual_col_iter</a> (matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one dual column iteration on a column simplex table.  <a href="#b23a59a732c583d329d98b0b2f697e04"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#37e3e08224ba23c55e1bfa55a0f0a6bb">Arageli::simplex_method::dual_col_iters</a> (matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous dual colunt iterations on a column simplex table.  <a href="#37e3e08224ba23c55e1bfa55a0f0a6bb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_nonbasis, bool REFCNT_nonbasis, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#fdeadc8c1c32264821d671a34ba3d7fc">Arageli::simplex_method::dual_col_iters</a> (matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous dual colunt iterations on a column simplex table.  <a href="#fdeadc8c1c32264821d671a34ba3d7fc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_nonbasis, bool REFCNT_nonbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#8ccad7f33d4322a0118b66512e604407">Arageli::simplex_method::dual_col_iters</a> (matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous dual column iterations on a column simplex table.  <a href="#8ccad7f33d4322a0118b66512e604407"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#7b89bdae0f535c5a55cfd364ebf0fdd4">Arageli::simplex_method::basis_create_by_artificial</a> (matrix&lt; T1, REFCNT1 &gt; &amp;q, vector&lt; T2, REFCNT2 &gt; &amp;basis, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produces a valid basis from artifical optimal simplex table due the artifical basis method.  <a href="#7b89bdae0f535c5a55cfd364ebf0fdd4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#738577b0c7fda1df56d9fbd304813489">Arageli::simplex_method::basis_create_by_artificial</a> (matrix&lt; T1, REFCNT1 &gt; &amp;a, vector&lt; T2, REFCNT2 &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produces a valid basis from artifical optimal simplex table due the artifical basis method.  <a href="#738577b0c7fda1df56d9fbd304813489"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T3, bool REFCNT3, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#e3eee94e8ca8fa0152c85e14acd1758d">Arageli::simplex_method::basis_artificial</a> (matrix&lt; T1, REFCNT1 &gt; &amp;q, vector&lt; T3, REFCNT3 &gt; &amp;basis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds primal allowable basis from simplex table q by artificial basis method.  <a href="#e3eee94e8ca8fa0152c85e14acd1758d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T3, bool REFCNT3, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#dda95aae4fb181b75423ed2eb911537f">Arageli::simplex_method::basis_artificial</a> (matrix&lt; T1, REFCNT1 &gt; &amp;q, vector&lt; T3, REFCNT3 &gt; &amp;basis, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds primal allowable basis from simplex table q by artificial basis method.  <a href="#dda95aae4fb181b75423ed2eb911537f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T3, bool REFCNT3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#903dafd6762291641fec3cf018c46f7b">Arageli::simplex_method::basis_artificial</a> (matrix&lt; T1, REFCNT1 &gt; &amp;q, vector&lt; T3, REFCNT3 &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds primal allowable basis from simplex table q by artificial basis method.  <a href="#903dafd6762291641fec3cf018c46f7b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#6cc71c5e0bc31491671e124bd4206dd1">Arageli::simplex_method::row_table_create</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;b, matrix&lt; T3, REFCNT3 &gt; &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creating of a row table from matrix A and vector b, with zeros in the first row.  <a href="#6cc71c5e0bc31491671e124bd4206dd1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#6df00d61ff3e3865a62ab4e17b8e3fd7">Arageli::simplex_method::row_table_place_c</a> (const vector&lt; T1, REFCNT1 &gt; &amp;c, matrix&lt; T2, REFCNT2 &gt; &amp;q)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#7d45e011528171d7475a221b968ff92c">Arageli::simplex_method::row_table_extract_c</a> (vector&lt; T1, REFCNT1 &gt; &amp;c, const matrix&lt; T2, REFCNT2 &gt; &amp;q)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#745f91f5622056aca39a5261cf46f840">Arageli::simplex_method::row_table_pivot_basis_c</a> (matrix&lt; T1, REFCNT1 &gt; &amp;q, const vector&lt; T2, REFCNT2 &gt; &amp;basis)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#176b7461c29e3703711f2d5a5d64870f">Arageli::simplex_method::row_table_extract_solution</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;q, const vector&lt; T2, REFCNT2 &gt; &amp;basis, vector&lt; T3, REFCNT3 &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename N, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#10ea2ffbc2668888f38aa2e0452fee9b">Arageli::simplex_method::col_table_extract_solution</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;t, const N &amp;n, vector&lt; T2, REFCNT2 &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3, typename T4, bool REFCNT4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#36e449e2e65f354cde134b31373a1a08">Arageli::simplex_method::row_table_create</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;b, const vector&lt; T3, REFCNT3 &gt; &amp;c, matrix&lt; T4, REFCNT4 &gt; &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creating of a row table from matrix A and vectors b, c.  <a href="#36e449e2e65f354cde134b31373a1a08"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T4, bool REFCNT4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#709be5c45c6680c135d986f01b910699">Arageli::simplex_method::row_table_split</a> (matrix&lt; T1, REFCNT1 &gt; &amp;a, vector&lt; T2, REFCNT2 &gt; &amp;b, const matrix&lt; T4, REFCNT4 &gt; &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creating of matrix A and vectors b, c from a row table q.  <a href="#709be5c45c6680c135d986f01b910699"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3, typename T4, bool REFCNT4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#03aa327d77c3e16e146e98210ae3c66c">Arageli::simplex_method::row_table_split</a> (matrix&lt; T1, REFCNT1 &gt; &amp;a, vector&lt; T2, REFCNT2 &gt; &amp;b, const vector&lt; T3, REFCNT3 &gt; &amp;c, const matrix&lt; T4, REFCNT4 &gt; &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creating of matrix A and vectors b, c from a row table q.  <a href="#03aa327d77c3e16e146e98210ae3c66c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3, typename T4, bool REFCNT4, typename T5, bool REFCNT5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#c42a488f80972f83ec3e90c9c1250cb2">Arageli::simplex_method::col_table_create_by_standard</a> (const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;b, const vector&lt; T3, REFCNT3 &gt; &amp;c, matrix&lt; T4, REFCNT4 &gt; &amp;t, vector&lt; T5, REFCNT5 &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes primal column table by given task in standard shape.  <a href="#c42a488f80972f83ec3e90c9c1250cb2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ta, bool REFCNTa, typename Tb, bool REFCNTb, typename Tc, bool REFCNTc, typename Tx, bool REFCNTx, typename Tbasis, bool REFCNTbasis, typename Tres, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#d8a9b522d65c839db24debb6ff7dc577">Arageli::simplex_method::primal_row_with_artificial_basis</a> (const matrix&lt; Ta, REFCNTa &gt; &amp;a, const vector&lt; Tb, REFCNTb &gt; &amp;b, const vector&lt; Tc, REFCNTc &gt; &amp;c, vector&lt; Tx, REFCNTx &gt; &amp;basis_x, vector&lt; Tbasis, REFCNTbasis &gt; &amp;basis, Tres &amp;res, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear programming problem with artificial basis method as zeroth step.  <a href="#d8a9b522d65c839db24debb6ff7dc577"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ta, bool REFCNTa, typename Tb, bool REFCNTb, typename Tc, bool REFCNTc, typename Tx, bool REFCNTx, typename Tbasis, bool REFCNTbasis, typename Tres&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#debbc2377d57c75eed70d8d9172792c0">Arageli::simplex_method::primal_row_with_artificial_basis</a> (const matrix&lt; Ta, REFCNTa &gt; &amp;a, const vector&lt; Tb, REFCNTb &gt; &amp;b, const vector&lt; Tc, REFCNTc &gt; &amp;c, vector&lt; Tx, REFCNTx &gt; &amp;basis_x, vector&lt; Tbasis, REFCNTbasis &gt; &amp;basis, Tres &amp;res)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear programming problem with artificial basis method as zeroth step.  <a href="#debbc2377d57c75eed70d8d9172792c0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#cf6119ab9f11629a9d2df4bb155aef46">Arageli::simplex_method::basis_to_nonbasis</a> (const vector&lt; T1, REFCNT1 &gt; &amp;basis, vector&lt; T2, REFCNT2 &gt; &amp;nonbasis, std::size_t first_number, std::size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes nonbasis by basis.  <a href="#cf6119ab9f11629a9d2df4bb155aef46"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#6e9aea9cef60db3c10aa145bb6ace600">Arageli::simplex_method::basis_to_nonbasis</a> (const vector&lt; T1, REFCNT1 &gt; &amp;basis, vector&lt; T2, REFCNT2 &gt; &amp;nonbasis, std::size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes nonbasis by basis.  <a href="#6e9aea9cef60db3c10aa145bb6ace600"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_basis, bool REFCNT_basis, typename T_T, bool REFCNT_T, typename T_nonbasis, bool REFCNT_nonbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#4118ce6ebf47ec180fea4ccf73506773">Arageli::simplex_method::row_to_col_table</a> (const matrix&lt; T_Q, REFCNT_Q &gt; &amp;q, const vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, matrix&lt; T_T, REFCNT_T &gt; &amp;t, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a valid simplex table from a row form to a column form.  <a href="#4118ce6ebf47ec180fea4ccf73506773"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_QT, bool REFCNT_QT, typename T_basis_nonbasis, bool REFCNT_basis_nonbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#d8b3ebea1d41c7066ac139725ea2a62f">Arageli::simplex_method::row_to_col_table</a> (matrix&lt; T_QT, REFCNT_QT &gt; &amp;qt, vector&lt; T_basis_nonbasis, REFCNT_basis_nonbasis &gt; &amp;basis_nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a valid simplex table from a row form to a column form.  <a href="#d8b3ebea1d41c7066ac139725ea2a62f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_basis, bool REFCNT_basis, typename T_DQ, bool REFCNT_DQ, typename T_Dbasis, bool REFCNT_Dbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#be86596f2b33d205430b821c657cbcfb">Arageli::simplex_method::primal_row_to_dual_row_table</a> (const matrix&lt; T_Q, REFCNT_Q &gt; &amp;q, const vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, matrix&lt; T_DQ, REFCNT_DQ &gt; &amp;dq, vector&lt; T_Dbasis, REFCNT_Dbasis &gt; &amp;dbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a dual row simplex table by primal row simplex table with selected basis.  <a href="#be86596f2b33d205430b821c657cbcfb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#a97fc859290488678e6e624250efecbe">Arageli::simplex_method::gomory1_iter</a> (matrix&lt; T1, REFCNT1 &gt; &amp;t, vector&lt; T2, REFCNT2 &gt; &amp;nonbasis, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One iteration of The First Gomory's Algorithm on an optimal column simplex table.  <a href="#a97fc859290488678e6e624250efecbe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#be7e1e6cfb5c39fcddf871ed821f2642">Arageli::simplex_method::gomory1_iters</a> (matrix&lt; T1, REFCNT1 &gt; &amp;t, vector&lt; T2, REFCNT2 &gt; &amp;nonbasis, Ctrler ctrler)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#f40a7e34762fb7d3dff27487402e9144">Arageli::simplex_method::gomory1_iters</a> (matrix&lt; T1, REFCNT1 &gt; &amp;t, vector&lt; T2, REFCNT2 &gt; &amp;nonbasis)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_a, bool REFCNT_a, typename T_b, bool REFCNT_b, typename T_c, bool REFCNT_c, typename T_da, bool REFCNT_da, typename T_db, bool REFCNT_db, typename T_dc, bool REFCNT_dc, typename T_basis, bool REFCNT_basis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#6b6f8afea56f195b6cee1dc78c4bf9a0">Arageli::simplex_method::primal_to_dual_canonical</a> (const matrix&lt; T_a, REFCNT_a &gt; &amp;a, const vector&lt; T_b, REFCNT_b &gt; &amp;b, const vector&lt; T_c, REFCNT_c &gt; &amp;c, matrix&lt; T_da, REFCNT_da &gt; &amp;da, vector&lt; T_db, REFCNT_db &gt; &amp;db, vector&lt; T_dc, REFCNT_dc &gt; &amp;dc, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the dual task in canonical shape by primal task.  <a href="#6b6f8afea56f195b6cee1dc78c4bf9a0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_a, bool REFCNT_a, typename T_b, bool REFCNT_b, typename T_c, bool REFCNT_c, typename T_basis, bool REFCNT_basis, typename T_da, bool REFCNT_da, typename T_db, bool REFCNT_db, typename T_dc, bool REFCNT_dc, typename T_res, typename T_ab, bool REFCNT_ab, typename T_cb, bool REFCNT_cb&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#f5e5d0a20099e6136b52cc115ffe8e67">Arageli::simplex_method::primal_to_dual_standard_discr</a> (const matrix&lt; T_a, REFCNT_a &gt; &amp;a, const vector&lt; T_b, REFCNT_b &gt; &amp;b, const vector&lt; T_c, REFCNT_c &gt; &amp;c, const vector&lt; T_basis, REFCNT_basis &gt; basis, matrix&lt; T_da, REFCNT_da &gt; &amp;da, vector&lt; T_db, REFCNT_db &gt; &amp;db, vector&lt; T_dc, REFCNT_dc &gt; &amp;dc, T_res &amp;res_offset, matrix&lt; T_ab, REFCNT_ab &gt; &amp;bsuba, vector&lt; T_cb, REFCNT_cb &gt; &amp;bsubc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the dual task in standard shape by primal task via introducing discrepancy variables.  <a href="#f5e5d0a20099e6136b52cc115ffe8e67"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#be38f4262b71e735585ad94a45c78f20">Arageli::simplex_method::output_list</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const linear_prog_task&lt; T, REFCNT &gt; &amp;lpt)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#a0fab4bd1806bb579a7b4ce11817b647">Arageli::simplex_method::input_list</a> (std::basic_istream&lt; Ch, ChT &gt; &amp;in, linear_prog_task&lt; T, REFCNT &gt; &amp;lpt)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#2b0eb783c4869f6ea5ba1e84ea3f729b">Arageli::simplex_method::output_aligned</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const linear_prog_task&lt; T, REFCNT &gt; &amp;lpt, const char *var=&quot;x&quot;)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Direct and dual simplex methods with different ways of choosing of pivot elements. Set of controller objects. There are as row as columnt methods, as noninteger as integer ones. 
<p>
Definition in file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.<hr><h2>Define Documentation</h2>
<a class="anchor" name="0e8d3805eef1a357fe480e5f0e373a2d"></a><!-- doxytag: member="simplex_method.hpp::ARAGELI_INCLUDE_CPP_WITH_EXPORT_TEMPLATE_SIMPLEX_METHOD" ref="0e8d3805eef1a357fe480e5f0e373a2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARAGELI_INCLUDE_CPP_WITH_EXPORT_TEMPLATE_SIMPLEX_METHOD          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02682">2682</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Aug 31 17:38:18 2006 for Arageli by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
