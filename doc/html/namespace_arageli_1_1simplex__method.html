<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Arageli: Arageli::simplex_method Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespace_arageli.html">Arageli</a>::<a class="el" href="namespace_arageli_1_1simplex__method.html">simplex_method</a></div>
<h1>Arageli::simplex_method Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1rule__s__primal__first.html">rule_s_primal_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule to choice the first appropriate column as pivot in the primal simplex method.  <a href="struct_arageli_1_1simplex__method_1_1rule__s__primal__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1rule__r__primal__first.html">rule_r_primal_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule to choice the first appropriate row as pivot in the primal simplex method.  <a href="struct_arageli_1_1simplex__method_1_1rule__r__primal__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1rule__r__primal__lex.html">rule_r_primal_lex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule to choice the lexmin appropriate row as pivot in the primal simplex method.  <a href="struct_arageli_1_1simplex__method_1_1rule__r__primal__lex.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1rule__r__dual__first.html">rule_r_dual_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule to choice the first appropriate row as pivot in the dual simplex method.  <a href="struct_arageli_1_1simplex__method_1_1rule__r__dual__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1rule__s__dual__first.html">rule_s_dual_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule to choice the first appropriate column as pivot in the dual simplex method.  <a href="struct_arageli_1_1simplex__method_1_1rule__s__dual__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1simplex__method_1_1linear__prog__task__base.html">linear_prog_task_base</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1simplex__method_1_1linear__prog__task.html">linear_prog_task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Model of the linear programming task with partial integer constraints.  <a href="class_arageli_1_1simplex__method_1_1linear__prog__task.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Looking for parts of a simplex table that is not satisfied certain criterion.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt;::size_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#1d6423aa66e8dfe9f76bb554bfdc3eb0">find_row_notallow</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the first not allowable basis column in a row simplex table.  <a href="#1d6423aa66e8dfe9f76bb554bfdc3eb0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt;::size_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#3a286fcd732b0d800db2da67d3f7270a">find_col_notallow</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the first not allowable basis row in a column simplex table.  <a href="#3a286fcd732b0d800db2da67d3f7270a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt;::size_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#c1551b14bd931a3136a656a79f72f7c5">find_primal_notallow</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the first not allowable row in a primal simplex table.  <a href="#c1551b14bd931a3136a656a79f72f7c5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt;::size_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#e0d5494eb3d0172b82e5eb39dfc94d9e">find_dual_notallow</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the first not allowable column in a dual simplex table.  <a href="#e0d5494eb3d0172b82e5eb39dfc94d9e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Determination type of a simplex table.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#ae299d52b5754eef4b7cb931dbc70bb9">is_row_allow</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if simplex table 'a' with basis 'basis' is row simplex table.  <a href="#ae299d52b5754eef4b7cb931dbc70bb9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#f90e3389612f89a617f71e017e8612ef">is_col_allow</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if simplex table 'a' with nonbasis 'nonbasis' is column simplex table.  <a href="#f90e3389612f89a617f71e017e8612ef"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#a9091e85b62b293d6ac96de8bd17e36a">is_primal_allow</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if simplex table 'a' is primal allowable.  <a href="#a9091e85b62b293d6ac96de8bd17e36a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#ec8036ab5d63334ccf70c908dd62df35">is_dual_allow</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if simplex table 'a' is dual allowable.  <a href="#ec8036ab5d63334ccf70c908dd62df35"></a><br></td></tr>
<tr><td colspan="2"><br><h2>The primal row iterations on a row simplex table.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename T_pivot, typename Rule_s, typename Rule_r&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#8448987e8a257d10932c95347913b9fd">primal_row_iter</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_q, REFCNT_q &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; &amp;basis, T_pivot &amp;prow, T_pivot &amp;pcol, Rule_s rule_s, Rule_r rule_r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one primal row iteration on a row simplex table.  <a href="#8448987e8a257d10932c95347913b9fd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#1a9f948924281eb8c87ef4c7c330ebfc">primal_row_iter</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_q, REFCNT_q &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one primal row iteration on a row simplex table.  <a href="#1a9f948924281eb8c87ef4c7c330ebfc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename Rule_s, typename Rule_r&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#ebee38df4371fceb43d2308137045e6a">primal_row_iter</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_q, REFCNT_q &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; &amp;basis, Rule_s rule_s, Rule_r rule_r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one primal row iteration on a row simplex table.  <a href="#ebee38df4371fceb43d2308137045e6a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename T_pivot&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#7c0c98b6f0efd108aa2208e8163b5bb7">primal_row_iter_pivotout</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_q, REFCNT_q &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; &amp;basis, T_pivot &amp;prow, T_pivot &amp;pcol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one primal row iteration on a row simplex table.  <a href="#7c0c98b6f0efd108aa2208e8163b5bb7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Artificial basis method.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#9df1c452c2514f5b0830426a27851d9c">artificial_basis_create</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates artificial task to find valid basis by the artifical basis method.  <a href="#9df1c452c2514f5b0830426a27851d9c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>The Gomory's algorithms.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename Prow&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#f482dc27ab9497074b083db85ba0b964">gomory1_clip</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T, REFCNT &gt; &amp;t, Prow &amp;prow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates Gomory's clip on optimal column simplex table.  <a href="#f482dc27ab9497074b083db85ba0b964"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#7e3086eb267e4646b6af8b3002c55d60">gomory1_clip</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T, REFCNT &gt; &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates Gomory's clip on optimal column simplex table.  <a href="#7e3086eb267e4646b6af8b3002c55d60"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> { <a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb82b7efdb2b1c7d7e713dc2994e28c05d1">rk_found</a>, 
<a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb818093ce7fda36b00c981f3b7fd8b82ac">rk_empty</a>, 
<a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8fa34f440778e0b21ed8f0ecf6beb9e94">rk_infinite</a>, 
<a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb82df658024b6527375fbc6c3e5e64e968">rk_nonoptimal</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">General kind of result of one or more iterations of the simplex method.  <a href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#7a4a7a2724a001ade6147f0e522a128b">primal_row_iters</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_q, REFCNT_q &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; &amp;basis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous primal row iterations on a row simplex table.  <a href="#7a4a7a2724a001ade6147f0e522a128b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#701d27f8228e91c6b4b7786c25eb06e5">primal_row_iters</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_q, REFCNT_q &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous primal row iterations on a row simplex table.  <a href="#701d27f8228e91c6b4b7786c25eb06e5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#ddaf738e002dcac01bb29ba4872bb4dd">primal_row_iters</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_q, REFCNT_q &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; &amp;basis, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous primal row iterations on a row simplex table.  <a href="#ddaf738e002dcac01bb29ba4872bb4dd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#cfb91f2ca05aea0249391bc2027dba9b">primal_col_iters</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_Q, REFCNT_Q &gt; &amp;Q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous primal colunt iterations on a column simplex table.  <a href="#cfb91f2ca05aea0249391bc2027dba9b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#12b7affc53c0c508e4f06bad8a38812a">primal_col_iters</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_Q, REFCNT_Q &gt; &amp;Q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous primal column iterations on a column simplex table.  <a href="#12b7affc53c0c508e4f06bad8a38812a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#0a4d6ef23a0fdef4b5f398cca7025218">dual_col_iter</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_Q, REFCNT_Q &gt; &amp;Q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one dual column iteration on a column simplex table.  <a href="#0a4d6ef23a0fdef4b5f398cca7025218"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#de8558c4783f9faf991b8b35902e379c">dual_col_iter</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_Q, REFCNT_Q &gt; &amp;Q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one dual column iteration on a column simplex table.  <a href="#de8558c4783f9faf991b8b35902e379c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#b23a59a732c583d329d98b0b2f697e04">dual_col_iter</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_Q, REFCNT_Q &gt; &amp;Q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one dual column iteration on a column simplex table.  <a href="#b23a59a732c583d329d98b0b2f697e04"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#37e3e08224ba23c55e1bfa55a0f0a6bb">dual_col_iters</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_Q, REFCNT_Q &gt; &amp;Q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous dual colunt iterations on a column simplex table.  <a href="#37e3e08224ba23c55e1bfa55a0f0a6bb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_nonbasis, bool REFCNT_nonbasis, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#fdeadc8c1c32264821d671a34ba3d7fc">dual_col_iters</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_q, REFCNT_q &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous dual colunt iterations on a column simplex table.  <a href="#fdeadc8c1c32264821d671a34ba3d7fc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_q, bool REFCNT_q, typename T_nonbasis, bool REFCNT_nonbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#8ccad7f33d4322a0118b66512e604407">dual_col_iters</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_q, REFCNT_q &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numerous dual column iterations on a column simplex table.  <a href="#8ccad7f33d4322a0118b66512e604407"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#7b89bdae0f535c5a55cfd364ebf0fdd4">basis_create_by_artificial</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;basis, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produces a valid basis from artifical optimal simplex table due the artifical basis method.  <a href="#7b89bdae0f535c5a55cfd364ebf0fdd4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#738577b0c7fda1df56d9fbd304813489">basis_create_by_artificial</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produces a valid basis from artifical optimal simplex table due the artifical basis method.  <a href="#738577b0c7fda1df56d9fbd304813489"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T3, bool REFCNT3, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#e3eee94e8ca8fa0152c85e14acd1758d">basis_artificial</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T3, REFCNT3 &gt; &amp;basis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds primal allowable basis from simplex table q by artificial basis method.  <a href="#e3eee94e8ca8fa0152c85e14acd1758d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T3, bool REFCNT3, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#dda95aae4fb181b75423ed2eb911537f">basis_artificial</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T3, REFCNT3 &gt; &amp;basis, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds primal allowable basis from simplex table q by artificial basis method.  <a href="#dda95aae4fb181b75423ed2eb911537f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T3, bool REFCNT3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#903dafd6762291641fec3cf018c46f7b">basis_artificial</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;q, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T3, REFCNT3 &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds primal allowable basis from simplex table q by artificial basis method.  <a href="#903dafd6762291641fec3cf018c46f7b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#6cc71c5e0bc31491671e124bd4206dd1">row_table_create</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;b, <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T3, REFCNT3 &gt; &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creating of a row table from matrix A and vector b, with zeros in the first row.  <a href="#6cc71c5e0bc31491671e124bd4206dd1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#6df00d61ff3e3865a62ab4e17b8e3fd7">row_table_place_c</a> (const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T1, REFCNT1 &gt; &amp;c, <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T2, REFCNT2 &gt; &amp;q)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#7d45e011528171d7475a221b968ff92c">row_table_extract_c</a> (<a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T1, REFCNT1 &gt; &amp;c, const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T2, REFCNT2 &gt; &amp;q)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#745f91f5622056aca39a5261cf46f840">row_table_pivot_basis_c</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;q, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;basis)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#176b7461c29e3703711f2d5a5d64870f">row_table_extract_solution</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;q, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;basis, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T3, REFCNT3 &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename N, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#10ea2ffbc2668888f38aa2e0452fee9b">col_table_extract_solution</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;t, const N &amp;n, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3, typename T4, bool REFCNT4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#36e449e2e65f354cde134b31373a1a08">row_table_create</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;b, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T3, REFCNT3 &gt; &amp;c, <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T4, REFCNT4 &gt; &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creating of a row table from matrix A and vectors b, c.  <a href="#36e449e2e65f354cde134b31373a1a08"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T4, bool REFCNT4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#709be5c45c6680c135d986f01b910699">row_table_split</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;b, const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T4, REFCNT4 &gt; &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creating of matrix A and vectors b, c from a row table q.  <a href="#709be5c45c6680c135d986f01b910699"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3, typename T4, bool REFCNT4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#03aa327d77c3e16e146e98210ae3c66c">row_table_split</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;b, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T3, REFCNT3 &gt; &amp;c, const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T4, REFCNT4 &gt; &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creating of matrix A and vectors b, c from a row table q.  <a href="#03aa327d77c3e16e146e98210ae3c66c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3, typename T4, bool REFCNT4, typename T5, bool REFCNT5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#c42a488f80972f83ec3e90c9c1250cb2">col_table_create_by_standard</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;b, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T3, REFCNT3 &gt; &amp;c, <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T4, REFCNT4 &gt; &amp;t, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T5, REFCNT5 &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes primal column table by given task in standard shape.  <a href="#c42a488f80972f83ec3e90c9c1250cb2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ta, bool REFCNTa, typename Tb, bool REFCNTb, typename Tc, bool REFCNTc, typename Tx, bool REFCNTx, typename Tbasis, bool REFCNTbasis, typename Tres, typename Rule_s, typename Rule_r, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#d8a9b522d65c839db24debb6ff7dc577">primal_row_with_artificial_basis</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; Ta, REFCNTa &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; Tb, REFCNTb &gt; &amp;b, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; Tc, REFCNTc &gt; &amp;c, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; Tx, REFCNTx &gt; &amp;basis_x, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; Tbasis, REFCNTbasis &gt; &amp;basis, Tres &amp;res, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear programming problem with artificial basis method as zeroth step.  <a href="#d8a9b522d65c839db24debb6ff7dc577"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ta, bool REFCNTa, typename Tb, bool REFCNTb, typename Tc, bool REFCNTc, typename Tx, bool REFCNTx, typename Tbasis, bool REFCNTbasis, typename Tres&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#debbc2377d57c75eed70d8d9172792c0">primal_row_with_artificial_basis</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; Ta, REFCNTa &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; Tb, REFCNTb &gt; &amp;b, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; Tc, REFCNTc &gt; &amp;c, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; Tx, REFCNTx &gt; &amp;basis_x, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; Tbasis, REFCNTbasis &gt; &amp;basis, Tres &amp;res)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear programming problem with artificial basis method as zeroth step.  <a href="#debbc2377d57c75eed70d8d9172792c0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#cf6119ab9f11629a9d2df4bb155aef46">basis_to_nonbasis</a> (const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T1, REFCNT1 &gt; &amp;basis, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;nonbasis, std::size_t first_number, std::size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes nonbasis by basis.  <a href="#cf6119ab9f11629a9d2df4bb155aef46"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#6e9aea9cef60db3c10aa145bb6ace600">basis_to_nonbasis</a> (const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T1, REFCNT1 &gt; &amp;basis, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;nonbasis, std::size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes nonbasis by basis.  <a href="#6e9aea9cef60db3c10aa145bb6ace600"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_basis, bool REFCNT_basis, typename T_T, bool REFCNT_T, typename T_nonbasis, bool REFCNT_nonbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#4118ce6ebf47ec180fea4ccf73506773">row_to_col_table</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_Q, REFCNT_Q &gt; &amp;q, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; &amp;basis, <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_T, REFCNT_T &gt; &amp;t, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a valid simplex table from a row form to a column form.  <a href="#4118ce6ebf47ec180fea4ccf73506773"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_QT, bool REFCNT_QT, typename T_basis_nonbasis, bool REFCNT_basis_nonbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#d8b3ebea1d41c7066ac139725ea2a62f">row_to_col_table</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_QT, REFCNT_QT &gt; &amp;qt, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis_nonbasis, REFCNT_basis_nonbasis &gt; &amp;basis_nonbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a valid simplex table from a row form to a column form.  <a href="#d8b3ebea1d41c7066ac139725ea2a62f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_Q, bool REFCNT_Q, typename T_basis, bool REFCNT_basis, typename T_DQ, bool REFCNT_DQ, typename T_Dbasis, bool REFCNT_Dbasis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#be86596f2b33d205430b821c657cbcfb">primal_row_to_dual_row_table</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_Q, REFCNT_Q &gt; &amp;q, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; &amp;basis, <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_DQ, REFCNT_DQ &gt; &amp;dq, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_Dbasis, REFCNT_Dbasis &gt; &amp;dbasis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a dual row simplex table by primal row simplex table with selected basis.  <a href="#be86596f2b33d205430b821c657cbcfb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#a97fc859290488678e6e624250efecbe">gomory1_iter</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;t, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;nonbasis, Ctrler ctrler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One iteration of The First Gomory's Algorithm on an optimal column simplex table.  <a href="#a97fc859290488678e6e624250efecbe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename Ctrler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#be7e1e6cfb5c39fcddf871ed821f2642">gomory1_iters</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;t, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;nonbasis, Ctrler ctrler)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#f40a7e34762fb7d3dff27487402e9144">gomory1_iters</a> (<a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T1, REFCNT1 &gt; &amp;t, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T2, REFCNT2 &gt; &amp;nonbasis)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_a, bool REFCNT_a, typename T_b, bool REFCNT_b, typename T_c, bool REFCNT_c, typename T_da, bool REFCNT_da, typename T_db, bool REFCNT_db, typename T_dc, bool REFCNT_dc, typename T_basis, bool REFCNT_basis&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#6b6f8afea56f195b6cee1dc78c4bf9a0">primal_to_dual_canonical</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_a, REFCNT_a &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_b, REFCNT_b &gt; &amp;b, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_c, REFCNT_c &gt; &amp;c, <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_da, REFCNT_da &gt; &amp;da, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_db, REFCNT_db &gt; &amp;db, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_dc, REFCNT_dc &gt; &amp;dc, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; &amp;basis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the dual task in canonical shape by primal task.  <a href="#6b6f8afea56f195b6cee1dc78c4bf9a0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T_a, bool REFCNT_a, typename T_b, bool REFCNT_b, typename T_c, bool REFCNT_c, typename T_basis, bool REFCNT_basis, typename T_da, bool REFCNT_da, typename T_db, bool REFCNT_db, typename T_dc, bool REFCNT_dc, typename T_res, typename T_ab, bool REFCNT_ab, typename T_cb, bool REFCNT_cb&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#f5e5d0a20099e6136b52cc115ffe8e67">primal_to_dual_standard_discr</a> (const <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_a, REFCNT_a &gt; &amp;a, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_b, REFCNT_b &gt; &amp;b, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_c, REFCNT_c &gt; &amp;c, const <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_basis, REFCNT_basis &gt; basis, <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_da, REFCNT_da &gt; &amp;da, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_db, REFCNT_db &gt; &amp;db, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_dc, REFCNT_dc &gt; &amp;dc, T_res &amp;res_offset, <a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt; T_ab, REFCNT_ab &gt; &amp;bsuba, <a class="el" href="class_arageli_1_1vector.html">vector</a>&lt; T_cb, REFCNT_cb &gt; &amp;bsubc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the dual task in standard shape by primal task via introducing discrepancy variables.  <a href="#f5e5d0a20099e6136b52cc115ffe8e67"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#be38f4262b71e735585ad94a45c78f20">output_list</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const <a class="el" href="class_arageli_1_1simplex__method_1_1linear__prog__task.html">linear_prog_task</a>&lt; T, REFCNT &gt; &amp;lpt)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#a0fab4bd1806bb579a7b4ce11817b647">input_list</a> (std::basic_istream&lt; Ch, ChT &gt; &amp;in, <a class="el" href="class_arageli_1_1simplex__method_1_1linear__prog__task.html">linear_prog_task</a>&lt; T, REFCNT &gt; &amp;lpt)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli_1_1simplex__method.html#2b0eb783c4869f6ea5ba1e84ea3f729b">output_aligned</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const <a class="el" href="class_arageli_1_1simplex__method_1_1linear__prog__task.html">linear_prog_task</a>&lt; T, REFCNT &gt; &amp;lpt, const char *var=&quot;x&quot;)</td></tr>

</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="b8a1badc6a99a9ba0a53b36876409fb8"></a><!-- doxytag: member="Arageli::simplex_method::result_kind" ref="b8a1badc6a99a9ba0a53b36876409fb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">Arageli::simplex_method::result_kind</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
General kind of result of one or more iterations of the simplex method. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="b8a1badc6a99a9ba0a53b36876409fb82b7efdb2b1c7d7e713dc2994e28c05d1"></a><!-- doxytag: member="rk_found" ref="b8a1badc6a99a9ba0a53b36876409fb82b7efdb2b1c7d7e713dc2994e28c05d1" args="" -->rk_found</em>&nbsp;</td><td>
an optimal vector is found </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b8a1badc6a99a9ba0a53b36876409fb818093ce7fda36b00c981f3b7fd8b82ac"></a><!-- doxytag: member="rk_empty" ref="b8a1badc6a99a9ba0a53b36876409fb818093ce7fda36b00c981f3b7fd8b82ac" args="" -->rk_empty</em>&nbsp;</td><td>
there are no allowable vectors </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b8a1badc6a99a9ba0a53b36876409fb8fa34f440778e0b21ed8f0ecf6beb9e94"></a><!-- doxytag: member="rk_infinite" ref="b8a1badc6a99a9ba0a53b36876409fb8fa34f440778e0b21ed8f0ecf6beb9e94" args="" -->rk_infinite</em>&nbsp;</td><td>
the criterion function is unbounded </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b8a1badc6a99a9ba0a53b36876409fb82df658024b6527375fbc6c3e5e64e968"></a><!-- doxytag: member="rk_nonoptimal" ref="b8a1badc6a99a9ba0a53b36876409fb82df658024b6527375fbc6c3e5e64e968" args="" -->rk_nonoptimal</em>&nbsp;</td><td>
an optimal vector is not found (to be found next iter) </td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00176">176</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="1d6423aa66e8dfe9f76bb554bfdc3eb0"></a><!-- doxytag: member="Arageli::simplex_method::find_row_notallow" ref="1d6423aa66e8dfe9f76bb554bfdc3eb0" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;basis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt;T1, REFCNT1&gt;::size_type Arageli::simplex_method::find_row_notallow           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the first not allowable basis column in a row simplex table. 
<p>
WARNING! EXPLANATION MAYBE INCORRECT. Suppose 'a' is a row simplex table corresponding the basis. The function finds the column such that 1) its number j (j &gt; 0) is contained in basis at position k, 2) there is a number i in {0, ..., a.nrows()-1} \ {k+1}, a(i, j) != 0, 3) a(k+1, j) == 1. Returns the first such index at 'basis', <a class="el" href="namespace_arageli.html#c0b326be389d39b82de76de8f4000ca7">i.e</a>. basis[return value] is such column number. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00061">61</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="3a286fcd732b0d800db2da67d3f7270a"></a><!-- doxytag: member="Arageli::simplex_method::find_col_notallow" ref="3a286fcd732b0d800db2da67d3f7270a" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;nonbasis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt;T1, REFCNT1&gt;::size_type Arageli::simplex_method::find_col_notallow           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the first not allowable basis row in a column simplex table. 
<p>
WARNING! EXPLANATION MAYBE INCORRECT. Suppose 'a' is a column simplex table corresponding the nonbasis. The function finds the row such that 1) its number j (j &gt; 0) is contained in nonbasis at position k, 2) there is a number i in {0, ..., a.ncols()-1} \ {k+1}, a(j, i) != 0, 3) a(j, k+1) == -1. Returns the first such index at 'nonbasis', <a class="el" href="namespace_arageli.html#c0b326be389d39b82de76de8f4000ca7">i.e</a>. nonbasis[return value] is such column number. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00089">89</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="c1551b14bd931a3136a656a79f72f7c5"></a><!-- doxytag: member="Arageli::simplex_method::find_primal_notallow" ref="c1551b14bd931a3136a656a79f72f7c5" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt;T1, REFCNT1&gt;::size_type Arageli::simplex_method::find_primal_notallow           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the first not allowable row in a primal simplex table. 
<p>
Finds the first row i that satisfies an expression a(i, j) &lt; 0 for some j (if any). If there is no such i, returns a.nrows(). 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00113">113</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="e0d5494eb3d0172b82e5eb39dfc94d9e"></a><!-- doxytag: member="Arageli::simplex_method::find_dual_notallow" ref="e0d5494eb3d0172b82e5eb39dfc94d9e" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_arageli_1_1matrix.html">matrix</a>&lt;T1, REFCNT1&gt;::size_type Arageli::simplex_method::find_dual_notallow           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the first not allowable column in a dual simplex table. 
<p>
Finds the first column j that satisfies an expression a(i, j) &lt; 0 for some i (if any). If there is no such j, returns a.ncols(). 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00128">128</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="ae299d52b5754eef4b7cb931dbc70bb9"></a><!-- doxytag: member="Arageli::simplex_method::is_row_allow" ref="ae299d52b5754eef4b7cb931dbc70bb9" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;basis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Arageli::simplex_method::is_row_allow           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if simplex table 'a' with basis 'basis' is row simplex table. 
<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00148">148</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="f90e3389612f89a617f71e017e8612ef"></a><!-- doxytag: member="Arageli::simplex_method::is_col_allow" ref="f90e3389612f89a617f71e017e8612ef" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;nonbasis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Arageli::simplex_method::is_col_allow           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if simplex table 'a' with nonbasis 'nonbasis' is column simplex table. 
<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00155">155</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="a9091e85b62b293d6ac96de8bd17e36a"></a><!-- doxytag: member="Arageli::simplex_method::is_primal_allow" ref="a9091e85b62b293d6ac96de8bd17e36a" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Arageli::simplex_method::is_primal_allow           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if simplex table 'a' is primal allowable. 
<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00162">162</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="ec8036ab5d63334ccf70c908dd62df35"></a><!-- doxytag: member="Arageli::simplex_method::is_dual_allow" ref="ec8036ab5d63334ccf70c908dd62df35" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Arageli::simplex_method::is_dual_allow           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if simplex table 'a' is dual allowable. 
<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00169">169</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="8448987e8a257d10932c95347913b9fd"></a><!-- doxytag: member="Arageli::simplex_method::primal_row_iter" ref="8448987e8a257d10932c95347913b9fd" args="(matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, T_pivot &amp;prow, T_pivot &amp;pcol, Rule_s rule_s, Rule_r rule_r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename T_pivot, typename Rule_s, typename Rule_r&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_row_iter           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_q, REFCNT_q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_basis, REFCNT_basis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_pivot &amp;&nbsp;</td>
          <td class="paramname"> <em>prow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_pivot &amp;&nbsp;</td>
          <td class="paramname"> <em>pcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_s&nbsp;</td>
          <td class="paramname"> <em>rule_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_r&nbsp;</td>
          <td class="paramname"> <em>rule_r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs one primal row iteration on a row simplex table. 
<p>
Performs the iteration, determines if the table is optimal or if there are no an optimum. The result value depends on status of input table, not output. In particular if not optimal table is passed to the algorithm and on the output we have an optimal table then the functions returns rk_nonoptimal. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>q</em>&nbsp;</td><td>
the simplex table </td></tr>
<tr><td valign="top"><em>basis</em>&nbsp;</td><td>
the basis </td></tr>
<tr><td valign="top"><em>prow</em>&nbsp;</td><td>
row number of pivot item (output, valid after call if table is nonoptimal) </td></tr>
<tr><td valign="top"><em>pcol</em>&nbsp;</td><td>
column number of pivot item (output, valid after call if table is nonoptimal) </td></tr>
<tr><td valign="top"><em>rule_s</em>&nbsp;</td><td>
the rule to choice a pivot column </td></tr>
<tr><td valign="top"><em>rule_r</em>&nbsp;</td><td>
the rule to choice a pivot row </td></tr>
</table>
</dl>
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00369">369</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="1a9f948924281eb8c87ef4c7c330ebfc"></a><!-- doxytag: member="Arageli::simplex_method::primal_row_iter" ref="1a9f948924281eb8c87ef4c7c330ebfc" args="(matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_row_iter           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_q, REFCNT_q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_basis, REFCNT_basis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs one primal row iteration on a row simplex table. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00404">404</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="ebee38df4371fceb43d2308137045e6a"></a><!-- doxytag: member="Arageli::simplex_method::primal_row_iter" ref="ebee38df4371fceb43d2308137045e6a" args="(matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, Rule_s rule_s, Rule_r rule_r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename Rule_s, typename Rule_r&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_row_iter           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_q, REFCNT_q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_basis, REFCNT_basis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_s&nbsp;</td>
          <td class="paramname"> <em>rule_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_r&nbsp;</td>
          <td class="paramname"> <em>rule_r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs one primal row iteration on a row simplex table. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00429">429</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="7c0c98b6f0efd108aa2208e8163b5bb7"></a><!-- doxytag: member="Arageli::simplex_method::primal_row_iter_pivotout" ref="7c0c98b6f0efd108aa2208e8163b5bb7" args="(matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, T_pivot &amp;prow, T_pivot &amp;pcol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename T_pivot&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_row_iter_pivotout           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_q, REFCNT_q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_basis, REFCNT_basis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_pivot &amp;&nbsp;</td>
          <td class="paramname"> <em>prow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_pivot &amp;&nbsp;</td>
          <td class="paramname"> <em>pcol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs one primal row iteration on a row simplex table. 
<p>
Just calls full vertion of the method primal_row_iter with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00450">450</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="7a4a7a2724a001ade6147f0e522a128b"></a><!-- doxytag: member="Arageli::simplex_method::primal_row_iters" ref="7a4a7a2724a001ade6147f0e522a128b" args="(matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_row_iters           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_q, REFCNT_q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_basis, REFCNT_basis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_s&nbsp;</td>
          <td class="paramname"> <em>rule_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_r&nbsp;</td>
          <td class="paramname"> <em>rule_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs numerous primal row iterations on a row simplex table. 
<p>
Performs the iteration, determines if the table is optimal or if there are no an optimum and so on until table becomes optimal. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00515">515</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="701d27f8228e91c6b4b7786c25eb06e5"></a><!-- doxytag: member="Arageli::simplex_method::primal_row_iters" ref="701d27f8228e91c6b4b7786c25eb06e5" args="(matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_row_iters           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_q, REFCNT_q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_basis, REFCNT_basis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs numerous primal row iterations on a row simplex table. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00562">562</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="ddaf738e002dcac01bb29ba4872bb4dd"></a><!-- doxytag: member="Arageli::simplex_method::primal_row_iters" ref="ddaf738e002dcac01bb29ba4872bb4dd" args="(matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_q, bool REFCNT_q, typename T_basis, bool REFCNT_basis, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_row_iters           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_q, REFCNT_q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_basis, REFCNT_basis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs numerous primal row iterations on a row simplex table. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00586">586</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="cfb91f2ca05aea0249391bc2027dba9b"></a><!-- doxytag: member="Arageli::simplex_method::primal_col_iters" ref="cfb91f2ca05aea0249391bc2027dba9b" args="(matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_col_iters           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_Q, REFCNT_Q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_s&nbsp;</td>
          <td class="paramname"> <em>rule_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_r&nbsp;</td>
          <td class="paramname"> <em>rule_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs numerous primal colunt iterations on a column simplex table. 
<p>
Performs the iteration, determines if the table is optimal or if there are no an optimum and so on until table becomes optimal. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00814">814</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="12b7affc53c0c508e4f06bad8a38812a"></a><!-- doxytag: member="Arageli::simplex_method::primal_col_iters" ref="12b7affc53c0c508e4f06bad8a38812a" args="(matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_col_iters           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_Q, REFCNT_Q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs numerous primal column iterations on a column simplex table. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00844">844</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="0a4d6ef23a0fdef4b5f398cca7025218"></a><!-- doxytag: member="Arageli::simplex_method::dual_col_iter" ref="0a4d6ef23a0fdef4b5f398cca7025218" args="(matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::dual_col_iter           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_Q, REFCNT_Q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_s&nbsp;</td>
          <td class="paramname"> <em>rule_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_r&nbsp;</td>
          <td class="paramname"> <em>rule_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs one dual column iteration on a column simplex table. 
<p>
Performs the iteration, determines if the table is optimal or if there are no an optimum. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00938">938</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="de8558c4783f9faf991b8b35902e379c"></a><!-- doxytag: member="Arageli::simplex_method::dual_col_iter" ref="de8558c4783f9faf991b8b35902e379c" args="(matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::dual_col_iter           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_Q, REFCNT_Q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs one dual column iteration on a column simplex table. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l00991">991</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="b23a59a732c583d329d98b0b2f697e04"></a><!-- doxytag: member="Arageli::simplex_method::dual_col_iter" ref="b23a59a732c583d329d98b0b2f697e04" args="(matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::dual_col_iter           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_Q, REFCNT_Q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_s&nbsp;</td>
          <td class="paramname"> <em>rule_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_r&nbsp;</td>
          <td class="paramname"> <em>rule_r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs one dual column iteration on a column simplex table. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01013">1013</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="37e3e08224ba23c55e1bfa55a0f0a6bb"></a><!-- doxytag: member="Arageli::simplex_method::dual_col_iters" ref="37e3e08224ba23c55e1bfa55a0f0a6bb" args="(matrix&lt; T_Q, REFCNT_Q &gt; &amp;Q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Q, bool REFCNT_Q, typename T_nonbasis, bool REFCNT_nonbasis, typename Rule_s, typename Rule_r, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::dual_col_iters           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_Q, REFCNT_Q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_s&nbsp;</td>
          <td class="paramname"> <em>rule_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_r&nbsp;</td>
          <td class="paramname"> <em>rule_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs numerous dual colunt iterations on a column simplex table. 
<p>
Performs the iteration, determines if the table is optimal or if there are no an optimum and so on until table becomes optimal. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01067">1067</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="fdeadc8c1c32264821d671a34ba3d7fc"></a><!-- doxytag: member="Arageli::simplex_method::dual_col_iters" ref="fdeadc8c1c32264821d671a34ba3d7fc" args="(matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_q, bool REFCNT_q, typename T_nonbasis, bool REFCNT_nonbasis, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::dual_col_iters           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_q, REFCNT_q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs numerous dual colunt iterations on a column simplex table. 
<p>
Rules of selection of pivot rows and columns are <a class="el" href="struct_arageli_1_1simplex__method_1_1rule__s__dual__first.html">rule_s_dual_first</a> and <a class="el" href="struct_arageli_1_1simplex__method_1_1rule__r__dual__first.html">rule_r_dual_first</a>. See complete version of this function. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01099">1099</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="8ccad7f33d4322a0118b66512e604407"></a><!-- doxytag: member="Arageli::simplex_method::dual_col_iters" ref="8ccad7f33d4322a0118b66512e604407" args="(matrix&lt; T_q, REFCNT_q &gt; &amp;q, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_q, bool REFCNT_q, typename T_nonbasis, bool REFCNT_nonbasis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::dual_col_iters           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_q, REFCNT_q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs numerous dual column iterations on a column simplex table. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01123">1123</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="9df1c452c2514f5b0830426a27851d9c"></a><!-- doxytag: member="Arageli::simplex_method::artificial_basis_create" ref="9df1c452c2514f5b0830426a27851d9c" args="(matrix&lt; T1, REFCNT1 &gt; &amp;a, vector&lt; T2, REFCNT2 &gt; &amp;basis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::artificial_basis_create           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates artificial task to find valid basis by the artifical basis method. 
<p>
New variables (and columns) will have been placed to the beginning of the table. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01145">1145</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="7b89bdae0f535c5a55cfd364ebf0fdd4"></a><!-- doxytag: member="Arageli::simplex_method::basis_create_by_artificial" ref="7b89bdae0f535c5a55cfd364ebf0fdd4" args="(matrix&lt; T1, REFCNT1 &gt; &amp;q, vector&lt; T2, REFCNT2 &gt; &amp;basis, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::basis_create_by_artificial           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Produces a valid basis from artifical optimal simplex table due the artifical basis method. 
<p>
The artifical variables must be located in the beginning of the table. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01221">1221</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="738577b0c7fda1df56d9fbd304813489"></a><!-- doxytag: member="Arageli::simplex_method::basis_create_by_artificial" ref="738577b0c7fda1df56d9fbd304813489" args="(matrix&lt; T1, REFCNT1 &gt; &amp;a, vector&lt; T2, REFCNT2 &gt; &amp;basis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::basis_create_by_artificial           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Produces a valid basis from artifical optimal simplex table due the artifical basis method. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01279">1279</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="e3eee94e8ca8fa0152c85e14acd1758d"></a><!-- doxytag: member="Arageli::simplex_method::basis_artificial" ref="e3eee94e8ca8fa0152c85e14acd1758d" args="(matrix&lt; T1, REFCNT1 &gt; &amp;q, vector&lt; T3, REFCNT3 &gt; &amp;basis, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T3, bool REFCNT3, typename Rule_s, typename Rule_r, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::basis_artificial           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T3, REFCNT3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_s&nbsp;</td>
          <td class="paramname"> <em>rule_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_r&nbsp;</td>
          <td class="paramname"> <em>rule_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds primal allowable basis from simplex table q by artificial basis method. 
<p>
After calling this method the old values of the first row of q is lost. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01344">1344</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="dda95aae4fb181b75423ed2eb911537f"></a><!-- doxytag: member="Arageli::simplex_method::basis_artificial" ref="dda95aae4fb181b75423ed2eb911537f" args="(matrix&lt; T1, REFCNT1 &gt; &amp;q, vector&lt; T3, REFCNT3 &gt; &amp;basis, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T3, bool REFCNT3, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::basis_artificial           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T3, REFCNT3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds primal allowable basis from simplex table q by artificial basis method. 
<p>
Rule of selection of row and column are by the default. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01397">1397</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="903dafd6762291641fec3cf018c46f7b"></a><!-- doxytag: member="Arageli::simplex_method::basis_artificial" ref="903dafd6762291641fec3cf018c46f7b" args="(matrix&lt; T1, REFCNT1 &gt; &amp;q, vector&lt; T3, REFCNT3 &gt; &amp;basis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T3, bool REFCNT3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::basis_artificial           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T3, REFCNT3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds primal allowable basis from simplex table q by artificial basis method. 
<p>
With default idle conroller. See complete version of this function. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01421">1421</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="6cc71c5e0bc31491671e124bd4206dd1"></a><!-- doxytag: member="Arageli::simplex_method::row_table_create" ref="6cc71c5e0bc31491671e124bd4206dd1" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;b, matrix&lt; T3, REFCNT3 &gt; &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::row_table_create           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T3, REFCNT3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creating of a row table from matrix A and vector b, with zeros in the first row. 
<p>
The result will have been placed into q. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01502">1502</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="6df00d61ff3e3865a62ab4e17b8e3fd7"></a><!-- doxytag: member="Arageli::simplex_method::row_table_place_c" ref="6df00d61ff3e3865a62ab4e17b8e3fd7" args="(const vector&lt; T1, REFCNT1 &gt; &amp;c, matrix&lt; T2, REFCNT2 &gt; &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::row_table_place_c           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01526">1526</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="7d45e011528171d7475a221b968ff92c"></a><!-- doxytag: member="Arageli::simplex_method::row_table_extract_c" ref="7d45e011528171d7475a221b968ff92c" args="(vector&lt; T1, REFCNT1 &gt; &amp;c, const matrix&lt; T2, REFCNT2 &gt; &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::row_table_extract_c           </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01544">1544</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="745f91f5622056aca39a5261cf46f840"></a><!-- doxytag: member="Arageli::simplex_method::row_table_pivot_basis_c" ref="745f91f5622056aca39a5261cf46f840" args="(matrix&lt; T1, REFCNT1 &gt; &amp;q, const vector&lt; T2, REFCNT2 &gt; &amp;basis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::row_table_pivot_basis_c           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01562">1562</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="176b7461c29e3703711f2d5a5d64870f"></a><!-- doxytag: member="Arageli::simplex_method::row_table_extract_solution" ref="176b7461c29e3703711f2d5a5d64870f" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;q, const vector&lt; T2, REFCNT2 &gt; &amp;basis, vector&lt; T3, REFCNT3 &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::row_table_extract_solution           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T3, REFCNT3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01579">1579</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="10ea2ffbc2668888f38aa2e0452fee9b"></a><!-- doxytag: member="Arageli::simplex_method::col_table_extract_solution" ref="10ea2ffbc2668888f38aa2e0452fee9b" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;t, const N &amp;n, vector&lt; T2, REFCNT2 &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename N, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::col_table_extract_solution           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>n</em>&nbsp;</td><td>
number of meaningful variables </td></tr>
</table>
</dl>
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01598">1598</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="36e449e2e65f354cde134b31373a1a08"></a><!-- doxytag: member="Arageli::simplex_method::row_table_create" ref="36e449e2e65f354cde134b31373a1a08" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;b, const vector&lt; T3, REFCNT3 &gt; &amp;c, matrix&lt; T4, REFCNT4 &gt; &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3, typename T4, bool REFCNT4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::row_table_create           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T3, REFCNT3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T4, REFCNT4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creating of a row table from matrix A and vectors b, c. 
<p>
The result will have been placed into q. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01620">1620</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="709be5c45c6680c135d986f01b910699"></a><!-- doxytag: member="Arageli::simplex_method::row_table_split" ref="709be5c45c6680c135d986f01b910699" args="(matrix&lt; T1, REFCNT1 &gt; &amp;a, vector&lt; T2, REFCNT2 &gt; &amp;b, const matrix&lt; T4, REFCNT4 &gt; &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T4, bool REFCNT4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::row_table_split           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T4, REFCNT4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creating of matrix A and vectors b, c from a row table q. 
<p>
The result will have been placed into a, b, c. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01642">1642</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="03aa327d77c3e16e146e98210ae3c66c"></a><!-- doxytag: member="Arageli::simplex_method::row_table_split" ref="03aa327d77c3e16e146e98210ae3c66c" args="(matrix&lt; T1, REFCNT1 &gt; &amp;a, vector&lt; T2, REFCNT2 &gt; &amp;b, const vector&lt; T3, REFCNT3 &gt; &amp;c, const matrix&lt; T4, REFCNT4 &gt; &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3, typename T4, bool REFCNT4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::row_table_split           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T3, REFCNT3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T4, REFCNT4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creating of matrix A and vectors b, c from a row table q. 
<p>
The result will have been placed into a, b, c. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01672">1672</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="c42a488f80972f83ec3e90c9c1250cb2"></a><!-- doxytag: member="Arageli::simplex_method::col_table_create_by_standard" ref="c42a488f80972f83ec3e90c9c1250cb2" args="(const matrix&lt; T1, REFCNT1 &gt; &amp;a, const vector&lt; T2, REFCNT2 &gt; &amp;b, const vector&lt; T3, REFCNT3 &gt; &amp;c, matrix&lt; T4, REFCNT4 &gt; &amp;t, vector&lt; T5, REFCNT5 &gt; &amp;nonbasis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename T3, bool REFCNT3, typename T4, bool REFCNT4, typename T5, bool REFCNT5&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::col_table_create_by_standard           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T3, REFCNT3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T4, REFCNT4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T5, REFCNT5 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes primal column table by given task in standard shape. 
<p>
Additional variables will have been placed to the end of the list of main variables. basis will have been filled by numbers additional variables. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01699">1699</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="d8a9b522d65c839db24debb6ff7dc577"></a><!-- doxytag: member="Arageli::simplex_method::primal_row_with_artificial_basis" ref="d8a9b522d65c839db24debb6ff7dc577" args="(const matrix&lt; Ta, REFCNTa &gt; &amp;a, const vector&lt; Tb, REFCNTb &gt; &amp;b, const vector&lt; Tc, REFCNTc &gt; &amp;c, vector&lt; Tx, REFCNTx &gt; &amp;basis_x, vector&lt; Tbasis, REFCNTbasis &gt; &amp;basis, Tres &amp;res, Rule_s rule_s, Rule_r rule_r, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ta, bool REFCNTa, typename Tb, bool REFCNTb, typename Tc, bool REFCNTc, typename Tx, bool REFCNTx, typename Tbasis, bool REFCNTbasis, typename Tres, typename Rule_s, typename Rule_r, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_row_with_artificial_basis           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; Ta, REFCNTa &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Tb, REFCNTb &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Tc, REFCNTc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Tx, REFCNTx &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Tbasis, REFCNTbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tres &amp;&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_s&nbsp;</td>
          <td class="paramname"> <em>rule_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rule_r&nbsp;</td>
          <td class="paramname"> <em>rule_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solves the linear programming problem with artificial basis method as zeroth step. 
<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01747">1747</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="debbc2377d57c75eed70d8d9172792c0"></a><!-- doxytag: member="Arageli::simplex_method::primal_row_with_artificial_basis" ref="debbc2377d57c75eed70d8d9172792c0" args="(const matrix&lt; Ta, REFCNTa &gt; &amp;a, const vector&lt; Tb, REFCNTb &gt; &amp;b, const vector&lt; Tc, REFCNTc &gt; &amp;c, vector&lt; Tx, REFCNTx &gt; &amp;basis_x, vector&lt; Tbasis, REFCNTbasis &gt; &amp;basis, Tres &amp;res)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ta, bool REFCNTa, typename Tb, bool REFCNTb, typename Tc, bool REFCNTc, typename Tx, bool REFCNTx, typename Tbasis, bool REFCNTbasis, typename Tres&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::primal_row_with_artificial_basis           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; Ta, REFCNTa &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Tb, REFCNTb &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Tc, REFCNTc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Tx, REFCNTx &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Tbasis, REFCNTbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tres &amp;&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solves the linear programming problem with artificial basis method as zeroth step. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01837">1837</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="cf6119ab9f11629a9d2df4bb155aef46"></a><!-- doxytag: member="Arageli::simplex_method::basis_to_nonbasis" ref="cf6119ab9f11629a9d2df4bb155aef46" args="(const vector&lt; T1, REFCNT1 &gt; &amp;basis, vector&lt; T2, REFCNT2 &gt; &amp;nonbasis, std::size_t first_number, std::size_t n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::basis_to_nonbasis           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>first_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes nonbasis by basis. 
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>first_number</em>&nbsp;</td><td>
number of first variable </td></tr>
<tr><td valign="top"><em>n</em>&nbsp;</td><td>
number of variables </td></tr>
</table>
</dl>
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01865">1865</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="6e9aea9cef60db3c10aa145bb6ace600"></a><!-- doxytag: member="Arageli::simplex_method::basis_to_nonbasis" ref="6e9aea9cef60db3c10aa145bb6ace600" args="(const vector&lt; T1, REFCNT1 &gt; &amp;basis, vector&lt; T2, REFCNT2 &gt; &amp;nonbasis, std::size_t n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::basis_to_nonbasis           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes nonbasis by basis. 
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>n</em>&nbsp;</td><td>
number of variables </td></tr>
</table>
</dl>
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01894">1894</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="4118ce6ebf47ec180fea4ccf73506773"></a><!-- doxytag: member="Arageli::simplex_method::row_to_col_table" ref="4118ce6ebf47ec180fea4ccf73506773" args="(const matrix&lt; T_Q, REFCNT_Q &gt; &amp;q, const vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, matrix&lt; T_T, REFCNT_T &gt; &amp;t, vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;nonbasis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Q, bool REFCNT_Q, typename T_basis, bool REFCNT_basis, typename T_T, bool REFCNT_T, typename T_nonbasis, bool REFCNT_nonbasis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::row_to_col_table           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T_Q, REFCNT_Q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T_basis, REFCNT_basis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T_T, REFCNT_T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_nonbasis, REFCNT_nonbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a valid simplex table from a row form to a column form. 
<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01910">1910</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="d8b3ebea1d41c7066ac139725ea2a62f"></a><!-- doxytag: member="Arageli::simplex_method::row_to_col_table" ref="d8b3ebea1d41c7066ac139725ea2a62f" args="(matrix&lt; T_QT, REFCNT_QT &gt; &amp;qt, vector&lt; T_basis_nonbasis, REFCNT_basis_nonbasis &gt; &amp;basis_nonbasis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_QT, bool REFCNT_QT, typename T_basis_nonbasis, bool REFCNT_basis_nonbasis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::row_to_col_table           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T_QT, REFCNT_QT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>qt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_basis_nonbasis, REFCNT_basis_nonbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis_nonbasis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a valid simplex table from a row form to a column form. 
<p>
Just calls full vertion of the method with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01965">1965</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="be86596f2b33d205430b821c657cbcfb"></a><!-- doxytag: member="Arageli::simplex_method::primal_row_to_dual_row_table" ref="be86596f2b33d205430b821c657cbcfb" args="(const matrix&lt; T_Q, REFCNT_Q &gt; &amp;q, const vector&lt; T_basis, REFCNT_basis &gt; &amp;basis, matrix&lt; T_DQ, REFCNT_DQ &gt; &amp;dq, vector&lt; T_Dbasis, REFCNT_Dbasis &gt; &amp;dbasis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Q, bool REFCNT_Q, typename T_basis, bool REFCNT_basis, typename T_DQ, bool REFCNT_DQ, typename T_Dbasis, bool REFCNT_Dbasis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::primal_row_to_dual_row_table           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T_Q, REFCNT_Q &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T_basis, REFCNT_basis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T_DQ, REFCNT_DQ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_Dbasis, REFCNT_Dbasis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dbasis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a dual row simplex table by primal row simplex table with selected basis. 
<p>
WARNING! IMPLEMENTATION MAYBE INCORRECT! A new simplex table negates vector of a goal function, thus you should negate the value of goal function if you want to have correct result. During building a new task formulation, this function introduces a set of new variables to prepare the task in the canonical shape. Those variables will have been placed into the end of new table. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l01995">1995</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="f482dc27ab9497074b083db85ba0b964"></a><!-- doxytag: member="Arageli::simplex_method::gomory1_clip" ref="f482dc27ab9497074b083db85ba0b964" args="(matrix&lt; T, REFCNT &gt; &amp;t, Prow &amp;prow)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool REFCNT, typename Prow&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::gomory1_clip           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, REFCNT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Prow &amp;&nbsp;</td>
          <td class="paramname"> <em>prow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates Gomory's clip on optimal column simplex table. 
<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02043">2043</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="7e3086eb267e4646b6af8b3002c55d60"></a><!-- doxytag: member="Arageli::simplex_method::gomory1_clip" ref="7e3086eb267e4646b6af8b3002c55d60" args="(matrix&lt; T, REFCNT &gt; &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool REFCNT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::gomory1_clip           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, REFCNT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates Gomory's clip on optimal column simplex table. 
<p>
Just calls the full version of the function with some default arguments. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02070">2070</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="a97fc859290488678e6e624250efecbe"></a><!-- doxytag: member="Arageli::simplex_method::gomory1_iter" ref="a97fc859290488678e6e624250efecbe" args="(matrix&lt; T1, REFCNT1 &gt; &amp;t, vector&lt; T2, REFCNT2 &gt; &amp;nonbasis, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::gomory1_iter           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
One iteration of The First Gomory's Algorithm on an optimal column simplex table. 
<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02143">2143</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="be7e1e6cfb5c39fcddf871ed821f2642"></a><!-- doxytag: member="Arageli::simplex_method::gomory1_iters" ref="be7e1e6cfb5c39fcddf871ed821f2642" args="(matrix&lt; T1, REFCNT1 &gt; &amp;t, vector&lt; T2, REFCNT2 &gt; &amp;nonbasis, Ctrler ctrler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2, typename Ctrler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::gomory1_iters           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ctrler&nbsp;</td>
          <td class="paramname"> <em>ctrler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02177">2177</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="f40a7e34762fb7d3dff27487402e9144"></a><!-- doxytag: member="Arageli::simplex_method::gomory1_iters" ref="f40a7e34762fb7d3dff27487402e9144" args="(matrix&lt; T1, REFCNT1 &gt; &amp;t, vector&lt; T2, REFCNT2 &gt; &amp;nonbasis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, bool REFCNT1, typename T2, bool REFCNT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_arageli_1_1simplex__method.html#b8a1badc6a99a9ba0a53b36876409fb8">result_kind</a> Arageli::simplex_method::gomory1_iters           </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T1, REFCNT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T2, REFCNT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nonbasis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02208">2208</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="6b6f8afea56f195b6cee1dc78c4bf9a0"></a><!-- doxytag: member="Arageli::simplex_method::primal_to_dual_canonical" ref="6b6f8afea56f195b6cee1dc78c4bf9a0" args="(const matrix&lt; T_a, REFCNT_a &gt; &amp;a, const vector&lt; T_b, REFCNT_b &gt; &amp;b, const vector&lt; T_c, REFCNT_c &gt; &amp;c, matrix&lt; T_da, REFCNT_da &gt; &amp;da, vector&lt; T_db, REFCNT_db &gt; &amp;db, vector&lt; T_dc, REFCNT_dc &gt; &amp;dc, vector&lt; T_basis, REFCNT_basis &gt; &amp;basis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_a, bool REFCNT_a, typename T_b, bool REFCNT_b, typename T_c, bool REFCNT_c, typename T_da, bool REFCNT_da, typename T_db, bool REFCNT_db, typename T_dc, bool REFCNT_dc, typename T_basis, bool REFCNT_basis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::primal_to_dual_canonical           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T_a, REFCNT_a &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T_b, REFCNT_b &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T_c, REFCNT_c &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T_da, REFCNT_da &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>da</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_db, REFCNT_db &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_dc, REFCNT_dc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_basis, REFCNT_basis &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes the dual task in canonical shape by primal task. 
<p>
Introcudes two additional set of variables: to limitation by sign, and to transforming from &gt;= to =. 
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02233">2233</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="f5e5d0a20099e6136b52cc115ffe8e67"></a><!-- doxytag: member="Arageli::simplex_method::primal_to_dual_standard_discr" ref="f5e5d0a20099e6136b52cc115ffe8e67" args="(const matrix&lt; T_a, REFCNT_a &gt; &amp;a, const vector&lt; T_b, REFCNT_b &gt; &amp;b, const vector&lt; T_c, REFCNT_c &gt; &amp;c, const vector&lt; T_basis, REFCNT_basis &gt; basis, matrix&lt; T_da, REFCNT_da &gt; &amp;da, vector&lt; T_db, REFCNT_db &gt; &amp;db, vector&lt; T_dc, REFCNT_dc &gt; &amp;dc, T_res &amp;res_offset, matrix&lt; T_ab, REFCNT_ab &gt; &amp;bsuba, vector&lt; T_cb, REFCNT_cb &gt; &amp;bsubc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_a, bool REFCNT_a, typename T_b, bool REFCNT_b, typename T_c, bool REFCNT_c, typename T_basis, bool REFCNT_basis, typename T_da, bool REFCNT_da, typename T_db, bool REFCNT_db, typename T_dc, bool REFCNT_dc, typename T_res, typename T_ab, bool REFCNT_ab, typename T_cb, bool REFCNT_cb&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Arageli::simplex_method::primal_to_dual_standard_discr           </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T_a, REFCNT_a &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T_b, REFCNT_b &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T_c, REFCNT_c &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T_basis, REFCNT_basis &gt;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T_da, REFCNT_da &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>da</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_db, REFCNT_db &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_dc, REFCNT_dc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_res &amp;&nbsp;</td>
          <td class="paramname"> <em>res_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T_ab, REFCNT_ab &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bsuba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T_cb, REFCNT_cb &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bsubc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes the dual task in standard shape by primal task via introducing discrepancy variables. 
<p>
The final dual task is formulated in the discrepancy variables set y = u*bsuba + bsubc, where bsuba is basis submatrix in a, bsubc is subvector of c that corresponds to bsuba. Native dual variables are found by u = (y+bsubc)*bsuba^(-1). Note the result task is formulated as "-max" task, so you should negate the result function value for THIS task to produce the result of original dual task. You must add value of res_offset to "-max" task result function value. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>bsuba</em>&nbsp;</td><td>
basis submatrix for a </td></tr>
<tr><td valign="top"><em>bsubc</em>&nbsp;</td><td>
basis subvector for c </td></tr>
</table>
</dl>
<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02292">2292</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="be38f4262b71e735585ad94a45c78f20"></a><!-- doxytag: member="Arageli::simplex_method::output_list" ref="be38f4262b71e735585ad94a45c78f20" args="(std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const linear_prog_task&lt; T, REFCNT &gt; &amp;lpt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool REFCNT, typename Ch, typename ChT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;Ch, ChT&gt;&amp; Arageli::simplex_method::output_list           </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const linear_prog_task&lt; T, REFCNT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lpt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02452">2452</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="a0fab4bd1806bb579a7b4ce11817b647"></a><!-- doxytag: member="Arageli::simplex_method::input_list" ref="a0fab4bd1806bb579a7b4ce11817b647" args="(std::basic_istream&lt; Ch, ChT &gt; &amp;in, linear_prog_task&lt; T, REFCNT &gt; &amp;lpt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool REFCNT, typename Ch, typename ChT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;Ch, ChT&gt;&amp; Arageli::simplex_method::input_list           </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linear_prog_task&lt; T, REFCNT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lpt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02474">2474</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<a class="anchor" name="2b0eb783c4869f6ea5ba1e84ea3f729b"></a><!-- doxytag: member="Arageli::simplex_method::output_aligned" ref="2b0eb783c4869f6ea5ba1e84ea3f729b" args="(std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const linear_prog_task&lt; T, REFCNT &gt; &amp;lpt, const char *var=&quot;x&quot;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool REFCNT, typename Ch, typename ChT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;Ch, ChT&gt;&amp; Arageli::simplex_method::output_aligned           </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const linear_prog_task&lt; T, REFCNT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>var</em> = <code>&quot;x&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="simplex__method_8hpp-source.html#l02562">2562</a> of file <a class="el" href="simplex__method_8hpp-source.html">simplex_method.hpp</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Aug 31 17:38:46 2006 for Arageli by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
