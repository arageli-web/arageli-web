<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Arageli: sparse_polynom.hpp File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>sparse_polynom.hpp File Reference</h1><code>#include &quot;<a class="el" href="config_8hpp-source.html">config.hpp</a>&quot;</code><br>
<code>#include &lt;iostream&gt;</code><br>
<code>#include &lt;list&gt;</code><br>
<code>#include &lt;iomanip&gt;</code><br>
<code>#include &lt;algorithm&gt;</code><br>
<code>#include &lt;cmath&gt;</code><br>
<code>#include &quot;<a class="el" href="frwrddecl_8hpp-source.html">frwrddecl.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="type__traits_8hpp-source.html">type_traits.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="exception_8hpp-source.html">exception.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="refcntr_8hpp-source.html">refcntr.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="iteradapt_8hpp-source.html">iteradapt.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="type__opers_8hpp-source.html">type_opers.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="factory_8hpp-source.html">factory.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="cmp_8hpp-source.html">cmp.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="io_8hpp-source.html">io.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="powerest_8hpp-source.html">powerest.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="big__int_8hpp-source.html">big_int.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="rational_8hpp-source.html">rational.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="__utility_8hpp-source.html">_utility.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="std__import_8hpp-source.html">std_import.hpp</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="sparse__polynom_8cpp-source.html">sparse_polynom.cpp</a>&quot;</code><br>

<p>
<a href="sparse__polynom_8hpp-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html">Arageli</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestd.html">std</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1monom.html">Arageli::monom&lt; F, I &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Monom template definition.  <a href="class_arageli_1_1monom.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1type__traits_3_01monom_3_01_f_00_01_i_01_4_01_4.html">Arageli::type_traits&lt; monom&lt; F, I &gt; &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1factory_3_01monom_3_01_f_00_01_i_01_4_01_4.html">Arageli::factory&lt; monom&lt; F, I &gt; &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1monom__degree__less.html">Arageli::monom_degree_less&lt; M1, M2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binary predicate for two monoms for degrees comparision.  <a href="struct_arageli_1_1monom__degree__less.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1monom__degree__equal.html">Arageli::monom_degree_equal&lt; M1, M2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binary predicate for two monoms for equality degrees determination.  <a href="struct_arageli_1_1monom__degree__equal.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1coef__extractor.html">Arageli::coef_extractor&lt; M &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Унарный функтор: по моному возвращает ссылку на его коэффициент.  <a href="struct_arageli_1_1coef__extractor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1degree__extractor.html">Arageli::degree_extractor&lt; M &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Унарный функтор: по моному возвращает ссылку на его степень.  <a href="struct_arageli_1_1degree__extractor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1norm__monom__seq__t.html">Arageli::norm_monom_seq_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type for helper object norm_monom_seq.  <a href="struct_arageli_1_1norm__monom__seq__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1any__monom__seq__t.html">Arageli::any_monom_seq_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type for helper object any_monom_seq.  <a href="struct_arageli_1_1any__monom__seq__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1sparse__polynom__base.html">Arageli::sparse_polynom_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base for all sparse polynomials.  <a href="struct_arageli_1_1sparse__polynom__base.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1sparse__polynom__base_1_1exception.html">Arageli::sparse_polynom_base::exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception of <a class="el" href="class_arageli_1_1sparse__polynom.html">sparse_polynom</a>.  <a href="class_arageli_1_1sparse__polynom__base_1_1exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1sparse__polynom__base_1_1division__by__zero.html">Arageli::sparse_polynom_base::division_by_zero</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Возникает при делении на нулевой полином.  <a href="class_arageli_1_1sparse__polynom__base_1_1division__by__zero.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1sparse__polynom__base_1_1zero__in__zero__degree.html">Arageli::sparse_polynom_base::zero_in_zero_degree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Возникает при возвединии нулевого полинома в нулевую степень.  <a href="class_arageli_1_1sparse__polynom__base_1_1zero__in__zero__degree.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arageli_1_1sparse__polynom.html">Arageli::sparse_polynom&lt; F, I, REFCNT &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1sparse__polynom_1_1other__coef.html">Arageli::sparse_polynom&lt; F, I, REFCNT &gt;::other_coef&lt; F1 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1factory_3_01sparse__polynom_3_01_f_00_01_i_00_01_r_e_f_c_n_t_01_4_01_4.html">Arageli::factory&lt; sparse_polynom&lt; F, I, REFCNT &gt; &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_arageli_1_1type__traits_3_01sparse__polynom_3_01_f_00_01_i_00_01_r_e_f_c_n_t_01_4_01_4.html">Arageli::type_traits&lt; sparse_polynom&lt; F, I, REFCNT &gt; &gt;</a></td></tr>

<tr><td colspan="2"><br><h2>Sorted and nonsorted helper objects.</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__polynom_8hpp.html#5c9255bbc47b20c28497c77ea13400f7">_ARAGELI_POLYNOM_BINOPER</a>(AOPER, BOPER)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e3f13c21faade5fe739c60f329a4c898">Arageli::monoms_order</a> { <a class="el" href="namespace_arageli.html#e3f13c21faade5fe739c60f329a4c898424c4c4bb6713194859ca4ed6ead3a5a">Arageli::mo_inc</a>, 
<a class="el" href="namespace_arageli.html#e3f13c21faade5fe739c60f329a4c8985ffa3af3a9f546ce478e0063773e5cc3">Arageli::mo_dec</a>
 }</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F, I, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#47751eaf5de1a1b2e64e484cf68d42f3">Arageli::diff</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pefrorms differentiation of polynomial x by common symbolic rules.  <a href="#47751eaf5de1a1b2e64e484cf68d42f3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#aa72f05bb89ae90ab7f5bab5d1402855">Arageli::output_list</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x, <a class="el" href="namespace_arageli.html#e3f13c21faade5fe739c60f329a4c898">monoms_order</a> mo=mo_inc, const char *first_bracket=<a class="el" href="namespace_arageli.html#a0b999c4625ca7aebb5b73a1749ea512">monom_output_list_first_bracket_default</a>, const char *second_bracket=<a class="el" href="namespace_arageli.html#86b78fa50a3e2d61ef91dcc4306543d6">monom_output_list_second_bracket_default</a>, const char *separator=<a class="el" href="namespace_arageli.html#81ae9170f56a2f70acc7daefe1bc4e8a">monom_output_list_separator_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple outputting as monom list.  <a href="#aa72f05bb89ae90ab7f5bab5d1402855"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#a09bb8c778761d3470c032085012d73d">Arageli::output_var</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x, <a class="el" href="namespace_arageli.html#e3f13c21faade5fe739c60f329a4c898">monoms_order</a> mo=mo_inc, const char *var=<a class="el" href="namespace_arageli.html#9da2666d3cb6644a32c8b0462593e1be">monom_output_var_var_default</a>, const char *mul=<a class="el" href="namespace_arageli.html#f8caba9cbd5105b2b2e3fd11854816bd">monom_output_var_mul_default</a>, const char *pow=<a class="el" href="namespace_arageli.html#b74f5a4ccb8604d9ff07571902adc83b">monom_output_var_pow_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Outputting of polynomial with variable symbol.  <a href="#a09bb8c778761d3470c032085012d73d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#94c006c7056cbbb6e7d8400799e8cb46">Arageli::input_list</a> (std::basic_istream&lt; Ch, ChT &gt; &amp;in, sparse_polynom&lt; F, I, REFCNT &gt; &amp;x, const char *first_bracket=<a class="el" href="namespace_arageli.html#c20089b1b3d608ecae54f0b5a991dd9a">monom_input_list_first_bracket_default</a>, const char *second_bracket=<a class="el" href="namespace_arageli.html#9257932922a8d0a6b113fbf245038213">monom_input_list_second_bracket_default</a>, const char *separator=<a class="el" href="namespace_arageli.html#fc5814452388ff84b0d65ac2e3afdb84">monom_input_list_separator_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple inputting of a polynomial.  <a href="#94c006c7056cbbb6e7d8400799e8cb46"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT, typename Ch, typename ChT, typename Coef_factory&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#c46c4eff74bd7386685ff88fccf6ea69">Arageli::input_var</a> (std::basic_istream&lt; Ch, ChT &gt; &amp;in, sparse_polynom&lt; F, I, REFCNT &gt; &amp;x, const Coef_factory &amp;fctr, const char *var=<a class="el" href="namespace_arageli.html#d8c8675f9268ff8994652a03a4cc9fd1">monom_input_var_var_default</a>, const char *mul=<a class="el" href="namespace_arageli.html#75c334074c6b1b333853cd9fbdc6d52e">monom_input_var_mul_default</a>, const char *pow=<a class="el" href="namespace_arageli.html#cf379a55c7e4899a782020beda79f506">monom_input_var_pow_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inputting of a polynomial with variable symbol.  <a href="#c46c4eff74bd7386685ff88fccf6ea69"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#bc0ca206145563aea04a9a38a420a6b2">Arageli::input_var</a> (std::basic_istream&lt; Ch, ChT &gt; &amp;in, sparse_polynom&lt; F, I, REFCNT &gt; &amp;x, const char *var=<a class="el" href="namespace_arageli.html#d8c8675f9268ff8994652a03a4cc9fd1">monom_input_var_var_default</a>, const char *mul=<a class="el" href="namespace_arageli.html#75c334074c6b1b333853cd9fbdc6d52e">monom_input_var_mul_default</a>, const char *pow=<a class="el" href="namespace_arageli.html#cf379a55c7e4899a782020beda79f506">monom_input_var_pow_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inputting of a polynomial with variable symbol.  <a href="#bc0ca206145563aea04a9a38a420a6b2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ch, typename ChT, typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#39f288f5382ccec20b51f8365c47da50">Arageli::output_aligned</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x, <a class="el" href="namespace_arageli.html#e3f13c21faade5fe739c60f329a4c898">monoms_order</a> mo=mo_inc, const char *var=<a class="el" href="namespace_arageli.html#9da2666d3cb6644a32c8b0462593e1be">monom_output_var_var_default</a>, const char *mul=<a class="el" href="namespace_arageli.html#f8caba9cbd5105b2b2e3fd11854816bd">monom_output_var_mul_default</a>, const char *pow=<a class="el" href="namespace_arageli.html#b74f5a4ccb8604d9ff07571902adc83b">monom_output_var_pow_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Oputputs polynomial in aligned form. (Restricted implementation.).  <a href="#39f288f5382ccec20b51f8365c47da50"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#307134dc47fc0bca5cfaa2ab85f33a75">Arageli::operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Станартный вывод полинома. Совпадает с sparse_polynom_output_var.  <a href="#307134dc47fc0bca5cfaa2ab85f33a75"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#349bb7966eb2d8d550fb8316965effba">Arageli::operator&gt;&gt;</a> (std::basic_istream&lt; Ch, ChT &gt; &amp;in, sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Станартный вывод полинома. Совпадает с sparse_polynom_input_var.  <a href="#349bb7966eb2d8d550fb8316965effba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const norm_monom_seq_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#95be70684340d067aa2b25671fdaf4e9">Arageli::norm_monom_seq</a> = norm_monom_seq_t()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper object for choosing method that gives sorted monom sequence.  <a href="#95be70684340d067aa2b25671fdaf4e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const any_monom_seq_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#3b788f01afc8c9ff6f3c1508807be03c">Arageli::any_monom_seq</a> = any_monom_seq_t()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper object for choosing method that gives unsorted monom sequence.  <a href="#3b788f01afc8c9ff6f3c1508807be03c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Standard comparision operators that based on cmp function.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#b817c87960cd998ada98c66399808ab1">Arageli::operator==</a> (const monom&lt; F1, I1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7e5ff98381824217dfc3925db124877c">Arageli::operator==</a> (const monom&lt; F1, I1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#450caf54d78db1e22b103bb113026939">Arageli::operator==</a> (const F1 &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#2d8f1cb2399d60c0fac894c67ddd8c8c">Arageli::operator!=</a> (const monom&lt; F1, I1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#3ace8003c199dc724fc11998ef0bd1b6">Arageli::operator!=</a> (const monom&lt; F1, I1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#4d2514687dfa84a49f520a4915198dbf">Arageli::operator!=</a> (const F1 &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#3c5016122293880fc269777a9c424f2c">Arageli::operator&lt;=</a> (const monom&lt; F1, I1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#cd8c8b5cdea284b9b42fd961c05f1cc5">Arageli::operator&lt;=</a> (const monom&lt; F1, I1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#23f4f3952b95082b4f9144a45bff3a01">Arageli::operator&lt;=</a> (const F1 &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#6e7b7c08c212939dae55fa3ee87411d4">Arageli::operator&gt;=</a> (const monom&lt; F1, I1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#831352d09152554d0cee056a7803b13c">Arageli::operator&gt;=</a> (const monom&lt; F1, I1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#ec57a912ed699779e0167e19c6a79555">Arageli::operator&gt;=</a> (const F1 &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#9d9a38565fbe07ec6a9617f278b6136a">Arageli::operator&lt;</a> (const monom&lt; F1, I1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#fab53366e0c78e9f3213d414506ea9c0">Arageli::operator&lt;</a> (const monom&lt; F1, I1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#25ad9c976ca04f0f93fb007f86eb5328">Arageli::operator&lt;</a> (const F1 &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#1d54f349da4e0c0864ab0a6a0b91b58f">Arageli::operator&gt;</a> (const monom&lt; F1, I1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e6a444953677b64922a251257e37e69b">Arageli::operator&gt;</a> (const monom&lt; F1, I1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#1e7d21c009515e3b3c1dd38cf974fe22">Arageli::operator&gt;</a> (const F1 &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td colspan="2"><br><h2>Дополнительные операторы для мономов; сочетание со скаляром.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F1, I1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#11226236d527000cbbcb017f2774792c">Arageli::operator+</a> (const monom&lt; F1, I1 &gt; &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F1, I1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#ec3eaad66b45614e4cd1bcf84a9c7841">Arageli::operator+</a> (const monom&lt; F1, I1 &gt; &amp;x, const F2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F2, I2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7e5142ceee8c5dddb1bba2356c3aeb3a">Arageli::operator+</a> (const F1 &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F1, I1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#c98c01dc7be796d51ddc69ecf116e4ba">Arageli::operator-</a> (const monom&lt; F1, I1 &gt; &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F1, I1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#a49ed1c0f7b0c793b51dd463dafcebb2">Arageli::operator-</a> (const monom&lt; F1, I1 &gt; &amp;x, const F2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F2, I2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#a52c91e8fd80207846bd4cc0a4286ec0">Arageli::operator-</a> (const F1 &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F1, I1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#a84806f555980af4eec1ef28fba2071d">Arageli::operator *</a> (const monom&lt; F1, I1 &gt; &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F1, I1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7740a7786fc514e8ee2ade96b7b852da">Arageli::operator *</a> (const monom&lt; F1, I1 &gt; &amp;x, const F2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F2, I2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#c0a79ddeb7af71dafe59960be292538d">Arageli::operator *</a> (const F1 &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F1, I1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#8cf26c0f274e3ced5c6372f454ee34b1">Arageli::operator/</a> (const monom&lt; F1, I1 &gt; &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F1, I1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#8481c068acee622647794b3485a520f6">Arageli::operator/</a> (const monom&lt; F1, I1 &gt; &amp;x, const F2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F2, I2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#2b4e69fd3d628f1f0fadfcebcb839301">Arageli::operator/</a> (const F1 &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F1, I1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#1a84963b5cba72fe08eb1605f4dcbd2e">Arageli::operator%</a> (const monom&lt; F1, I1 &gt; &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F1, I1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#5c9950b6c37a28f97bd29b0e29de103e">Arageli::operator%</a> (const monom&lt; F1, I1 &gt; &amp;x, const F2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F2, I2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#74b3d4f36ab042d06c0eb3d4b0bb7dad">Arageli::operator%</a> (const F1 &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td colspan="2"><br><h2>Дополнительные операторы для мономов; сочетание со скаляром.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#ff2a46be48a6c5313a0e0d2ba18d3e6d">Arageli::operator+</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#69bfec25bd9112e44b9d712a56d4c419">Arageli::operator+</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F2, I2, REFCNT2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#58464afb588fd68bc0fcacf5f9b2f113">Arageli::operator+</a> (const monom&lt; F1, I1 &gt; &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#00d62b5a1b5c2a3eaf37babd486e1e40">Arageli::operator+</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const F2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F2, I2, REFCNT2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#c48ef1c534f566b2866f5d1f975cf242">Arageli::operator+</a> (const F1 &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; rational&lt;<br>
 F1 &gt;, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#846d498978032070dfca8b6abccc268b">Arageli::operator+</a> (const sparse_polynom&lt; rational&lt; F1 &gt;, I1, REFCNT1 &gt; &amp;x, const rational&lt; F1 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; rational&lt;<br>
 F1 &gt;, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#6b18b87d4f5f48cca709f68ded36386e">Arageli::operator+</a> (const rational&lt; F1 &gt; &amp;x, const sparse_polynom&lt; rational&lt; F1 &gt;, I1, REFCNT1 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#b9ed14b11e8f3265e641ce9aee07ae3d">Arageli::operator-</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#fa14710ac06ba102239492b95ef6988a">Arageli::operator-</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F2, I2, REFCNT2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#8b5177c008c069199926392b6e69d213">Arageli::operator-</a> (const monom&lt; F1, I1 &gt; &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#a028cab05b71f4cc81a6d2ac9ae45045">Arageli::operator-</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const F2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F2, I2, REFCNT2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#3ccf1729e523e278c3fac4ccab3026c1">Arageli::operator-</a> (const F1 &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; rational&lt;<br>
 F1 &gt;, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#316c2a51a7f186fd55faadd691df9533">Arageli::operator-</a> (const sparse_polynom&lt; rational&lt; F1 &gt;, I1, REFCNT1 &gt; &amp;x, const rational&lt; F1 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; rational&lt;<br>
 F1 &gt;, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#c48b1ab2e4c99cb8f7cf428f5050a68e">Arageli::operator-</a> (const rational&lt; F1 &gt; &amp;x, const sparse_polynom&lt; rational&lt; F1 &gt;, I1, REFCNT1 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#d5afae70d00c62cd0a6ca010cf5041e8">Arageli::operator *</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#aad02bbac1df0159816d26eda34e6b41">Arageli::operator *</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F2, I2, REFCNT2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#b30e0eb8a1f4697010d544b45d38f62d">Arageli::operator *</a> (const monom&lt; F1, I1 &gt; &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e7800d20c9f729d34b59bb5d7b5046f0">Arageli::operator *</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const F2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F2, I2, REFCNT2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#4bd96b901fb5d710c32622d90e99bac4">Arageli::operator *</a> (const F1 &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; rational&lt;<br>
 F1 &gt;, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#d9eebf35058eb91b79f7ec4101b8d1be">Arageli::operator *</a> (const sparse_polynom&lt; rational&lt; F1 &gt;, I1, REFCNT1 &gt; &amp;x, const rational&lt; F1 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; rational&lt;<br>
 F1 &gt;, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e65d20ee4fe4a02657a6931aa916d361">Arageli::operator *</a> (const rational&lt; F1 &gt; &amp;x, const sparse_polynom&lt; rational&lt; F1 &gt;, I1, REFCNT1 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#8d0dd50cde4a6dee13e08b8f882a29fb">Arageli::operator/</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#32c7a2c22c21feaa9ff80e75ffce2b9f">Arageli::operator/</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F2, I2, REFCNT2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#ceef5223ef41a8891b1cec6ae756bb93">Arageli::operator/</a> (const monom&lt; F1, I1 &gt; &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#15ae108f63dd3b53bc5152911ede57ca">Arageli::operator/</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const F2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F2, I2, REFCNT2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#36dad393e4c7087357b46a0bfa14de6a">Arageli::operator/</a> (const F1 &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; rational&lt;<br>
 F1 &gt;, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#56d8c63ac5f3599e4429cd413231c72b">Arageli::operator/</a> (const sparse_polynom&lt; rational&lt; F1 &gt;, I1, REFCNT1 &gt; &amp;x, const rational&lt; F1 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; rational&lt;<br>
 F1 &gt;, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#8358bd6a40dbcc8abba10978fd0a008d">Arageli::operator/</a> (const rational&lt; F1 &gt; &amp;x, const sparse_polynom&lt; rational&lt; F1 &gt;, I1, REFCNT1 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#67d4d460dc06edcc9d03589d849d2d4d">Arageli::operator%</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7033d4e022f88eb3af2cde2c0cc9c0b1">Arageli::operator%</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const monom&lt; F2, I2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F2, I2, REFCNT2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#f481e9dbc4b69b072aa314304a03bcda">Arageli::operator%</a> (const monom&lt; F1, I1 &gt; &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7ca494a3cf8053f97f620186d1044886">Arageli::operator%</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;x, const F2 &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F2, I2, REFCNT2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#ba71a08319011742b9b5f962fe22b8c7">Arageli::operator%</a> (const F1 &amp;x, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; rational&lt;<br>
 F1 &gt;, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e21795b10e4c5234fb309b0ea8271592">Arageli::operator%</a> (const sparse_polynom&lt; rational&lt; F1 &gt;, I1, REFCNT1 &gt; &amp;x, const rational&lt; F1 &gt; &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; rational&lt;<br>
 F1 &gt;, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#9defb705764d4f619c9961f417a96030">Arageli::operator%</a> (const rational&lt; F1 &gt; &amp;x, const sparse_polynom&lt; rational&lt; F1 &gt;, I1, REFCNT1 &gt; &amp;y)</td></tr>

<tr><td colspan="2"><br><h2>Standard comparision operators that based on cmp function.</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#5b9681029af2e5772b97b2e45758b60e">Arageli::operator==</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7a84aa3c4737a95bcbf87ea2b9e63c4d">Arageli::operator==</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#4919aff9bd1990638a651b8a71f65c79">Arageli::operator==</a> (const monom&lt; F1, I1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#c90920274ca00570bc792eb79363f848">Arageli::operator==</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#2bb01cc93500d46bcae039e51148a4b6">Arageli::operator==</a> (const F1 &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#28695e90f0dbf0d05fc802b757e5cd6b">Arageli::operator!=</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#758cab97b91cce9274bbcbef327bd7ce">Arageli::operator!=</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e0ba21d251824a7a1bcc4b612349f684">Arageli::operator!=</a> (const monom&lt; F1, I1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#1ed4fc552a4f6c1827e1193ae69587c8">Arageli::operator!=</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#0f7ef1ec9f64c7ffd124b7b4786dca0c">Arageli::operator!=</a> (const F1 &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#96f9aebd99494d8f14b4e983247d9ad2">Arageli::operator&lt;=</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#d77ddd11693f47bc98bc6eafbc88c28e">Arageli::operator&lt;=</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#cd2688ac7dc66029e6a0e8bf9bd9e720">Arageli::operator&lt;=</a> (const monom&lt; F1, I1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#5ab7a33d4b5c89e181ec521ffdaa7a1c">Arageli::operator&lt;=</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e01e38ef25a69ed5fcdaae7ca3dc3f69">Arageli::operator&lt;=</a> (const F1 &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#81fa5adb115536c00131888dbc08f28d">Arageli::operator&gt;=</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#d5a1ab6500f43384c9770656e90c4eca">Arageli::operator&gt;=</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#31df7d919c194891ec8abd78e37a6d27">Arageli::operator&gt;=</a> (const monom&lt; F1, I1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#f4c385da83a770d69186f0e4d5b55159">Arageli::operator&gt;=</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#064bbc22f1661c31c180407ac4277963">Arageli::operator&gt;=</a> (const F1 &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#832adcb9e7fafab5e0d9ce656c9b3082">Arageli::operator&lt;</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#19c8885123bcc5092996787b8f91c8ba">Arageli::operator&lt;</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e2ee1924b01dceeec8da8d9e82626d90">Arageli::operator&lt;</a> (const monom&lt; F1, I1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#89e92fe53d79e0cb9b411bb8698dee64">Arageli::operator&lt;</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#9e6846c68b0e9c92fc04579c16f6d4fc">Arageli::operator&lt;</a> (const F1 &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#5583b6429a787a8d0edfb1f79a4d4f71">Arageli::operator&gt;</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#3377c3d2d6084643525f581a19e21fac">Arageli::operator&gt;</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const monom&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#480848d26d5b6803c3ac509e0c411e55">Arageli::operator&gt;</a> (const monom&lt; F1, I1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#4277d31d2e54c27c387e248dba7ca354">Arageli::operator&gt;</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#d636c364c10127bf78211dabba183210">Arageli::operator&gt;</a> (const F1 &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__polynom_8hpp.html#80fed31ed743dce608de665d9fcc4b89">_ARAGELI_MONOM_CMP</a>(OPER)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__polynom_8hpp.html#871688ed6ab6c8e34e693e364b61fb3b">_ARAGELI_MONOM_BINOPER</a>(AOPER, BOPER)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__polynom_8hpp.html#79169e2a5d9923f28f4afc3f4057e766">_ARAGELI_SPARSE_POLYNOMIAL_CMP</a>(OPER)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__polynom_8hpp.html#80fb7521888896219217eed5d39dda25">ARAGELI_INCLUDE_CPP_WITH_EXPORT_TEMPLATE_SPARSE_POLYNOM</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#9009c60c7fea198097bbc57ad789955f">Arageli::is_unit</a> (const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#5c20969d7b594667006c8746ab9eb08b">Arageli::is_opposite_unit</a> (const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#5e042e3a7750e009e7adfb3f5f38ee18">Arageli::is_null</a> (const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F, I &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7e31daf11b5b9512b05e28d917f525bf">Arageli::opposite</a> (const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F, I &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e8fa8ee7104b76a3506f7fc069b9c9fd">Arageli::opposite</a> (const monom&lt; F, I &gt; &amp;x, monom&lt; F, I &gt; *y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F, I &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#21def740539069fba50a459cd272478d">Arageli::opposite</a> (monom&lt; F, I &gt; *x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F, I &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#f7771b60964555b2b763571022fc5505">Arageli::inverse</a> (const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F, I &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#58369cf3ea4a369593a577ccc84058c9">Arageli::inverse</a> (const monom&lt; F, I &gt; &amp;x, monom&lt; F, I &gt; *y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F, I &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#3d0013bbfe1f2566d8b08455ef59967c">Arageli::inverse</a> (monom&lt; F, I &gt; *x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#19e80453ce346f6e486e3c3976f2dcbc">Arageli::output_polynom_first</a> (std::ostream &amp;out, const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#070a502a975eb46bba8349ef2fb924c0">Arageli::output_polynom_internal</a> (std::ostream &amp;out, const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#1e2ded47aac5fdf0d092aeb1c8b0f3ef">Arageli::output_pow</a> (std::ostream &amp;out, const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#b66f8bcbe83f51b370319470fd09b4b5">Arageli::input_polynom_first</a> (std::istream &amp;in, monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#b5d6f3c4bfe338f26f03b81bc501a0a8">Arageli::input_polynom_internal</a> (std::istream &amp;in, monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#91a31b3bcc8d4b134a31975d8e2fd28d">Arageli::input_pow</a> (std::istream &amp;in, monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#ca73165e8f28a70f87d8fbf7b779cee3">Arageli::cmp</a> (const monom&lt; F1, I1 &gt; &amp;m1, const monom&lt; F2, I2 &gt; &amp;m2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#a4f0fc5bc2387f6cd03b604a9005e2b2">Arageli::cmp</a> (const monom&lt; F1, I1 &gt; &amp;m1, const F2 &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#68e6917f408104a736b409682846c348">Arageli::cmp</a> (const F1 &amp;a, const monom&lt; F2, I2 &gt; &amp;m2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, typename Factory_coef&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#34969d0a7ade51fe1f9125c8eb7441d4">Arageli::sign</a> (const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the sign of monom, <a class="el" href="namespace_arageli.html#c0b326be389d39b82de76de8f4000ca7">i.e</a>. sign of the its coefficient.  <a href="#34969d0a7ade51fe1f9125c8eb7441d4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ch, typename ChT, typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#5cfe1fe8eb2f0622cd99a8bbf3dd9345">Arageli::output_list</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const monom&lt; F, I &gt; &amp;x, const char *first_bracket=<a class="el" href="namespace_arageli.html#a0b999c4625ca7aebb5b73a1749ea512">monom_output_list_first_bracket_default</a>, const char *second_bracket=<a class="el" href="namespace_arageli.html#86b78fa50a3e2d61ef91dcc4306543d6">monom_output_list_second_bracket_default</a>, const char *separator=<a class="el" href="namespace_arageli.html#81ae9170f56a2f70acc7daefe1bc4e8a">monom_output_list_separator_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple outputting of monom.  <a href="#5cfe1fe8eb2f0622cd99a8bbf3dd9345"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ch, typename ChT, typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#4f6ebf6ac7e81cccff33c1cb0e5f370e">Arageli::output_var</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const monom&lt; F, I &gt; &amp;x, bool first_a=true, const char *var=<a class="el" href="namespace_arageli.html#9da2666d3cb6644a32c8b0462593e1be">monom_output_var_var_default</a>, const char *mul=<a class="el" href="namespace_arageli.html#f8caba9cbd5105b2b2e3fd11854816bd">monom_output_var_mul_default</a>, const char *pow=<a class="el" href="namespace_arageli.html#b74f5a4ccb8604d9ff07571902adc83b">monom_output_var_pow_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Выводит моном в привычном виде, с указанием формальной переменной.  <a href="#4f6ebf6ac7e81cccff33c1cb0e5f370e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ch, typename ChT, typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#0619c781ad95e039a0c280538c1cab5a">Arageli::input_list</a> (std::basic_istream&lt; Ch, ChT &gt; &amp;in, monom&lt; F, I &gt; &amp;x, const char *first_bracket=<a class="el" href="namespace_arageli.html#c20089b1b3d608ecae54f0b5a991dd9a">monom_input_list_first_bracket_default</a>, const char *second_bracket=<a class="el" href="namespace_arageli.html#9257932922a8d0a6b113fbf245038213">monom_input_list_second_bracket_default</a>, const char *separator=<a class="el" href="namespace_arageli.html#fc5814452388ff84b0d65ac2e3afdb84">monom_input_list_separator_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple intputting for monom.  <a href="#0619c781ad95e039a0c280538c1cab5a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ch, typename ChT, typename F, typename I, typename Factory_coef&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#0ccde69f1937f1960668fcb8426ec013">Arageli::input_var</a> (std::basic_istream&lt; Ch, ChT &gt; &amp;in, monom&lt; F, I &gt; &amp;x, bool first_a, const Factory_coef &amp;fctr, const char *var=<a class="el" href="namespace_arageli.html#d8c8675f9268ff8994652a03a4cc9fd1">monom_input_var_var_default</a>, const char *mul=<a class="el" href="namespace_arageli.html#75c334074c6b1b333853cd9fbdc6d52e">monom_input_var_mul_default</a>, const char *pow=<a class="el" href="namespace_arageli.html#cf379a55c7e4899a782020beda79f506">monom_input_var_pow_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inputting with variable symbol for monom.  <a href="#0ccde69f1937f1960668fcb8426ec013"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ch, typename ChT, typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#9762c799e58d6f4bec12432d7000bd19">Arageli::input_var</a> (std::basic_istream&lt; Ch, ChT &gt; &amp;in, monom&lt; F, I &gt; &amp;x, bool first_a=true, const char *var=<a class="el" href="namespace_arageli.html#d8c8675f9268ff8994652a03a4cc9fd1">monom_input_var_var_default</a>, const char *mul=<a class="el" href="namespace_arageli.html#75c334074c6b1b333853cd9fbdc6d52e">monom_input_var_mul_default</a>, const char *pow=<a class="el" href="namespace_arageli.html#cf379a55c7e4899a782020beda79f506">monom_input_var_pow_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inputting with variable symbol for monom.  <a href="#9762c799e58d6f4bec12432d7000bd19"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ch, typename ChT, typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7d0671e81c75212b8c1fc51415132f07">Arageli::output_aligned</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const monom&lt; F, I &gt; &amp;x, bool first_a=true, const char *var=<a class="el" href="namespace_arageli.html#9da2666d3cb6644a32c8b0462593e1be">monom_output_var_var_default</a>, const char *mul=<a class="el" href="namespace_arageli.html#f8caba9cbd5105b2b2e3fd11854816bd">monom_output_var_mul_default</a>, const char *pow=<a class="el" href="namespace_arageli.html#b74f5a4ccb8604d9ff07571902adc83b">monom_output_var_pow_default</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Oputputs monom in aligned form. (Restricted implementation.).  <a href="#7d0671e81c75212b8c1fc51415132f07"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7f842e2e694b7f1f74940a2ae230c4ce">Arageli::operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, ChT &gt; &amp;out, const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Стандартный способ вывода монома: совпадает с output_var.  <a href="#7f842e2e694b7f1f74940a2ae230c4ce"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, typename Ch, typename ChT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_istream&lt; Ch, ChT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#4b366c33dcff66a2b006914dc3ad82ab">Arageli::operator&gt;&gt;</a> (std::basic_istream&lt; Ch, ChT &gt; &amp;in, monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Стандартный способ ввода монома: совпадает с input_var.  <a href="#4b366c33dcff66a2b006914dc3ad82ab"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7b6c63196e1747b113e6614c777c31b6">Arageli::cmp</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparision of two polynomials.  <a href="#7b6c63196e1747b113e6614c777c31b6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#37fd974c673c4e4861d7ddbba6db5722">Arageli::is_primitive</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#fa44efb47f75b27bea27c67935e72ef4">Arageli::is_unit</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#2d4272133c7868976f800f8928eecce5">Arageli::is_opposite_unit</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#0b405de6289d581afd56d46b4fe0a370">Arageli::is_null</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F, I, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#b6b4c574c46dd8dd41505c1981d253b5">Arageli::opposite</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F, I, REFCNT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#e031d2245c0251dd6dcc8ecdc5fd5694">Arageli::opposite</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x, sparse_polynom&lt; F, I, REFCNT &gt; *y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F, I, REFCNT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#a03db089b6ee000b5bf2032f1d019415">Arageli::opposite</a> (sparse_polynom&lt; F, I, REFCNT &gt; *x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F, I, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#f84a64527ba3c3efab8722906e5d4533">Arageli::inverse</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F, I, REFCNT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#01a1ff55207b063de7b25e31e1acb1a4">Arageli::inverse</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x, sparse_polynom&lt; F, I, REFCNT &gt; *y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F, I, REFCNT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#62dd78cf67bbcb432d6ffcd25e04307b">Arageli::inverse</a> (sparse_polynom&lt; F, I, REFCNT &gt; *x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#7dc613aa93535797f879bf205a49ee71">Arageli::output_polynom_first</a> (std::ostream &amp;out, const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#f4dd9781398d0b6924e58cf2cde6922f">Arageli::output_polynom_internal</a> (std::ostream &amp;out, const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#468a4b40231276ad4b31debccd7eb43e">Arageli::output_pow</a> (std::ostream &amp;out, const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#6a4e376ef9addb9db38dc97477a1bf38">Arageli::input_polynom_first</a> (std::istream &amp;in, sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#58f80572e2ba095015b4cce3588d6fef">Arageli::input_polynom_internal</a> (std::istream &amp;in, sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#5653f4cae26a7f2d7ad26813b8b3c93f">Arageli::input_pow</a> (std::istream &amp;in, sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F, I, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#3abaf5e3e26d165b37da68d0302a30cf">Arageli::euclid</a> (sparse_polynom&lt; F, I, REFCNT &gt; a, sparse_polynom&lt; F, I, REFCNT &gt; b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of euclid for <a class="el" href="class_arageli_1_1sparse__polynom.html">sparse_polynom</a>.  <a href="#3abaf5e3e26d165b37da68d0302a30cf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#c85891ecd6f1ba4e4626784d5c2a5be8">Arageli::is_coprime</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;a, const sparse_polynom&lt; F, I, REFCNT &gt; &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of is_coprime for <a class="el" href="class_arageli_1_1sparse__polynom.html">sparse_polynom</a>.  <a href="#c85891ecd6f1ba4e4626784d5c2a5be8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2, typename Q, typename R&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#ad81005497ef84c4adcc60c612d212dc">Arageli::prdivide</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const sparse_polynom&lt; F2, I2, REFCNT2 &gt; &amp;b, Q &amp;q, R &amp;r)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F1, I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#3807d590740923d4df6e29806a62d51a">Arageli::pow</a> (const sparse_polynom&lt; F1, I1, REFCNT1 &gt; &amp;a, const I2 &amp;n)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">monom&lt; F, I &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#cc5f405d7e605032b9e8e0774eb3b72c">Arageli::abs</a> (const monom&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute value for monom.  <a href="#cc5f405d7e605032b9e8e0774eb3b72c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sparse_polynom&lt; F, I, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#020acf470a810e37ae3b18f70db1ddda">Arageli::abs</a> (const sparse_polynom&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute value for polynomial.  <a href="#020acf470a810e37ae3b18f70db1ddda"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="class_arageli_1_1sparse__polynom.html">Arageli::sparse_polynom</a>&lt; F1,<br>
 I1, REFCNT1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#ff64f9707362df1b71a9ab5cd7b27de0">std::pow</a> (const <a class="el" href="class_arageli_1_1sparse__polynom.html">Arageli::sparse_polynom</a>&lt; F1, I1, REFCNT1 &gt; &amp;a, const I2 &amp;n)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, typename F2, typename I2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#3e800cbfe23af19ba3d369e7c6285197">std::swap</a> (<a class="el" href="class_arageli_1_1monom.html">Arageli::monom</a>&lt; F1, I1 &gt; &amp;a, <a class="el" href="class_arageli_1_1monom.html">Arageli::monom</a>&lt; F2, I2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F1, typename I1, bool REFCNT1, typename F2, typename I2, bool REFCNT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#fd2414925aa34d287d9d49558274f395">std::swap</a> (<a class="el" href="class_arageli_1_1sparse__polynom.html">Arageli::sparse_polynom</a>&lt; F1, I1, REFCNT1 &gt; &amp;a, <a class="el" href="class_arageli_1_1sparse__polynom.html">Arageli::sparse_polynom</a>&lt; F2, I2, REFCNT2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#2ea27ae8a5913e791b6a15311180ae1a">std::swap</a> (<a class="el" href="class_arageli_1_1monom.html">Arageli::monom</a>&lt; F, I &gt; &amp;a, <a class="el" href="class_arageli_1_1monom.html">Arageli::monom</a>&lt; F, I &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#b016d07690fe94186e53819bed319bcc">std::swap</a> (<a class="el" href="class_arageli_1_1sparse__polynom.html">Arageli::sparse_polynom</a>&lt; F, I, REFCNT &gt; &amp;a, <a class="el" href="class_arageli_1_1sparse__polynom.html">Arageli::sparse_polynom</a>&lt; F, I, REFCNT &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="class_arageli_1_1monom.html">Arageli::monom</a>&lt; F, I &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#ec0f0d2cb9761b06d058ef5fed2b1d05">std::abs</a> (const <a class="el" href="class_arageli_1_1monom.html">Arageli::monom</a>&lt; F, I &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute value for monom.  <a href="#ec0f0d2cb9761b06d058ef5fed2b1d05"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F, typename I, bool REFCNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="class_arageli_1_1sparse__polynom.html">Arageli::sparse_polynom</a>&lt; F,<br>
 I, REFCNT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#296776c1dc71b17c329d22f782900db4">std::abs</a> (const <a class="el" href="class_arageli_1_1sparse__polynom.html">Arageli::sparse_polynom</a>&lt; F, I, REFCNT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute value for polynomial.  <a href="#296776c1dc71b17c329d22f782900db4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#c20089b1b3d608ecae54f0b5a991dd9a">Arageli::monom_input_list_first_bracket_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#a0b999c4625ca7aebb5b73a1749ea512">Arageli::monom_output_list_first_bracket_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#9257932922a8d0a6b113fbf245038213">Arageli::monom_input_list_second_bracket_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#86b78fa50a3e2d61ef91dcc4306543d6">Arageli::monom_output_list_second_bracket_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#fc5814452388ff84b0d65ac2e3afdb84">Arageli::monom_input_list_separator_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#81ae9170f56a2f70acc7daefe1bc4e8a">Arageli::monom_output_list_separator_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#75c334074c6b1b333853cd9fbdc6d52e">Arageli::monom_input_var_mul_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#f8caba9cbd5105b2b2e3fd11854816bd">Arageli::monom_output_var_mul_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#d8c8675f9268ff8994652a03a4cc9fd1">Arageli::monom_input_var_var_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#9da2666d3cb6644a32c8b0462593e1be">Arageli::monom_output_var_var_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#cf379a55c7e4899a782020beda79f506">Arageli::monom_input_var_pow_default</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_arageli.html#b74f5a4ccb8604d9ff07571902adc83b">Arageli::monom_output_var_pow_default</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Sparse polinomial and related classes and operations definition. This file contains following definitions for following class templates: monom, sparse_polynom and the partialy specialization of type_traits template for monom and sparse_polynom. Generaly sparse polynomial is a list of monoms with appropriate type for coefficient and degree. 
<p>
Definition in file <a class="el" href="sparse__polynom_8hpp-source.html">sparse_polynom.hpp</a>.<hr><h2>Define Documentation</h2>
<a class="anchor" name="871688ed6ab6c8e34e693e364b61fb3b"></a><!-- doxytag: member="sparse_polynom.hpp::_ARAGELI_MONOM_BINOPER" ref="871688ed6ab6c8e34e693e364b61fb3b" args="(AOPER, BOPER)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _ARAGELI_MONOM_BINOPER          </td>
          <td>(</td>
          <td class="paramtype">AOPER,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOPER&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="sparse__polynom_8hpp-source.html#l00766">766</a> of file <a class="el" href="sparse__polynom_8hpp-source.html">sparse_polynom.hpp</a>.
</div>
</div><p>
<a class="anchor" name="80fed31ed743dce608de665d9fcc4b89"></a><!-- doxytag: member="sparse_polynom.hpp::_ARAGELI_MONOM_CMP" ref="80fed31ed743dce608de665d9fcc4b89" args="(OPER)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _ARAGELI_MONOM_CMP          </td>
          <td>(</td>
          <td class="paramtype">OPER&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F1, <span class="keyword">typename</span> I1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> I2&gt;           \
    <span class="keyword">inline</span> <span class="keywordtype">bool</span> <span class="keyword">operator</span> OPER                                               \
    (<span class="keyword">const</span> monom&lt;F1, I1&gt;&amp; a, <span class="keyword">const</span> monom&lt;F2, I2&gt;&amp; b)                        \
    { <span class="keywordflow">return</span> <a class="code" href="namespace_arageli.html#fce1837bd3ba2ec4817e1ac2f9c76c06">cmp</a>(a, b) OPER 0; }                                            \
                                                                            \
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F1, <span class="keyword">typename</span> I1, <span class="keyword">typename</span> F2&gt;                        \
    <span class="keyword">inline</span> <span class="keywordtype">bool</span> <span class="keyword">operator</span> OPER                                               \
    (                                                                       \
        <span class="keyword">const</span> monom&lt;F1, I1&gt;&amp; a,                                             \
        <span class="keyword">const</span> F2&amp; b                                                         \
    )                                                                       \
    { <span class="keywordflow">return</span> <a class="code" href="namespace_arageli.html#fce1837bd3ba2ec4817e1ac2f9c76c06">cmp</a>(a, b) OPER 0; }                                            \
                                                                            \
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> I2&gt;                        \
    <span class="keyword">inline</span> <span class="keywordtype">bool</span> <span class="keyword">operator</span> OPER                                               \
    (                                                                       \
        <span class="keyword">const</span> F1&amp; a,                                                        \
        <span class="keyword">const</span> monom&lt;F2, I2&gt;&amp; b                                              \
    )                                                                       \
    { <span class="keywordflow">return</span> <a class="code" href="namespace_arageli.html#fce1837bd3ba2ec4817e1ac2f9c76c06">cmp</a>(a, b) OPER 0; }
</pre></div>
<p>
Definition at line <a class="el" href="sparse__polynom_8hpp-source.html#l00550">550</a> of file <a class="el" href="sparse__polynom_8hpp-source.html">sparse_polynom.hpp</a>.
</div>
</div><p>
<a class="anchor" name="5c9255bbc47b20c28497c77ea13400f7"></a><!-- doxytag: member="sparse_polynom.hpp::_ARAGELI_POLYNOM_BINOPER" ref="5c9255bbc47b20c28497c77ea13400f7" args="(AOPER, BOPER)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _ARAGELI_POLYNOM_BINOPER          </td>
          <td>(</td>
          <td class="paramtype">AOPER,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOPER&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="sparse__polynom_8hpp-source.html#l01884">1884</a> of file <a class="el" href="sparse__polynom_8hpp-source.html">sparse_polynom.hpp</a>.
</div>
</div><p>
<a class="anchor" name="79169e2a5d9923f28f4afc3f4057e766"></a><!-- doxytag: member="sparse_polynom.hpp::_ARAGELI_SPARSE_POLYNOMIAL_CMP" ref="79169e2a5d9923f28f4afc3f4057e766" args="(OPER)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _ARAGELI_SPARSE_POLYNOMIAL_CMP          </td>
          <td>(</td>
          <td class="paramtype">OPER&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="sparse__polynom_8hpp-source.html#l02075">2075</a> of file <a class="el" href="sparse__polynom_8hpp-source.html">sparse_polynom.hpp</a>.
</div>
</div><p>
<a class="anchor" name="80fb7521888896219217eed5d39dda25"></a><!-- doxytag: member="sparse_polynom.hpp::ARAGELI_INCLUDE_CPP_WITH_EXPORT_TEMPLATE_SPARSE_POLYNOM" ref="80fb7521888896219217eed5d39dda25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARAGELI_INCLUDE_CPP_WITH_EXPORT_TEMPLATE_SPARSE_POLYNOM          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="sparse__polynom_8hpp-source.html#l02615">2615</a> of file <a class="el" href="sparse__polynom_8hpp-source.html">sparse_polynom.hpp</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Aug 31 17:38:18 2006 for Arageli by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
